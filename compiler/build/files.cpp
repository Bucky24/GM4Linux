#include "files.h"
map<string,string *> files;
string main_cpp;
string common_h;
string Engine_cpp;
string Objects_h;
string Room_cpp;
string Image_h;
string Makefile;
string ObjectType_h;
string Rooms_h;
string Engine_h;
string Image_cpp;
string Object_cpp;
string Object_h;
string ObjectType_cpp;
string Room_h;
string common_cpp;
void initFiles() {
files = *(new map<string,string *>());
main_cpp = "\n#include <iostream>\n\n#include <stdlib.h>\n\n#ifdef __APPLE__\n\n#include <OpenGL/OpenGL.h>\n\n#include <GLUT/glut.h>\n\n#else\n\n#include <GL/glut.h>\n\n#endif\n\n#include \"Image.h\"\n\n#include \"ObjectType.h\"\n\n#include \"Objects.h\"\n\n#include \"Room.h\"\n\n#include <cstdio>\n\n#include \"Engine.h\"\n\n#include \"Rooms.h\"\n\n#include <cstdlib>\nusing namespace std;\nconst float BOX_SIZE = 70.0f; //The length of each side of the cube\nconst float WINDOW_WIDTH = 800;const float WINDOW_HEIGHT = 600;\n//testobject *inst;\n\n//int objectid;\n\n//int instanceid;\nvoid handleKeypress(unsigned char key, int x, int y) {        (*Engine::keys->find(key)).second = true;\n        //Engine::keys[key] = true;\n switch (key) {\n  case 27: //Escape key\n   exit(0); }}void handleMouse(int button, int state, int x, int y) { if (button == GLUT_LEFT_BUTTON) {  if (state == GLUT_DOWN) {   Engine::mouse_left_flagged = true;  } else if (state == GLUT_UP) {   Engine::mouse_left_flagged = false;   } } else if (button == GLUT_RIGHT_BUTTON) {  if (state == GLUT_DOWN) {   Engine::mouse_right_flagged = true;  } else if (state == GLUT_UP) {   Engine::mouse_right_flagged = false;   } } else if (button == GLUT_MIDDLE_BUTTON) {  if (state == GLUT_DOWN) {   Engine::mouse_center_flagged = true;  } else if (state == GLUT_UP) {   Engine::mouse_center_flagged = false;   } } Engine::setMouse(x,y);}void handleMouseMotion(int x, int y) { Engine::setMouse(x,y);}void handleSpecialKeypress(int key, int x, int y) {        (*Engine::keys->find(key+200)).second = true;}void initRendering() { glEnable(GL_DEPTH_TEST); glEnable(GL_LIGHTING); glEnable(GL_LIGHT0); glEnable(GL_NORMALIZE); glEnable(GL_COLOR_MATERIAL);        Engine::init();}void handleResize(int w, int h) { glViewport(0, 0, w, h); glMatrixMode(GL_PROJECTION); glLoadIdentity(); glOrtho(0,WINDOW_WIDTH,WINDOW_HEIGHT,0,-100,1000);}void drawScene() { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glClearColor(Engine::currentRoom->r, Engine::currentRoom->g, Engine::currentRoom->b,0);        Engine::currentRoom->draw();  glutSwapBuffers();}void update(int value) {\n        // begin step\n        Engine::beginStep();\n        // fire events\n        Engine::handleEvents();\n        // collision\n        Engine::checkCollisions();\n        // step\n        Engine::step();\n        // end step\n        Engine::endStep();\n        // draw\n glutPostRedisplay(); glutTimerFunc(1000/Engine::currentRoom->getSpeed(), update, 0);}int main(int argc, char** argv) { glutInit(&argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH); glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);  glutCreateWindow(\"Game name!\"); initRendering();        if (Engine::currentRoom == NULL) {                cout << \"No rooms defined.\" << endl;                exit(1);        }  glutDisplayFunc(drawScene); glutKeyboardFunc(handleKeypress); glutSpecialFunc(handleSpecialKeypress); glutMouseFunc(handleMouse); glutMotionFunc(handleMouseMotion); glutPassiveMotionFunc(handleMouseMotion); glutReshapeFunc(handleResize); glutTimerFunc(1, update, 0);  glutMainLoop(); return 0;}";
files.insert(pair<string,string*>("main_cpp",&main_cpp));
common_h = "\n#ifndef COMMONH\n\n#define COMMONH\n\n#include <vector>\n\n#include \"Engine.h\"\n\n#include <iostream>\n/* -- OBJECT DEFINITIONS -- */using namespace std;extern int instance_create(unsigned int id, int x, int y);extern void draw_sprite(unsigned int sprite, int offset, float x, float y);extern void draw_line(float x1, float y1, float x2, float y2);extern int instance_number(int object);extern Object *instance_find(int object, int number);extern void draw_set_color_rgb(int r, int g, int b);extern void draw_point(float x, float y);\n#endif\n";
files.insert(pair<string,string*>("common_h",&common_h));
Engine_cpp = "\n#include \"Engine.h\"\n\n#include <cstdlib>\n\n#include \"Rooms.h\"\nvector<ObjectType *> Engine::objectref;vector<Image *> Engine::imageref;vector<Object *> Engine::instanceref;vector<Room *> Engine::roomref;int Engine::instanceid = 0;Room *Engine::currentRoom;keyhitmap *Engine::keys;keyhitmap *Engine::keyslaststep;bool Engine::mouse_left_flagged;bool Engine::mouse_left_flagged_laststep;bool Engine::mouse_right_flagged;bool Engine::mouse_right_flagged_laststep;bool Engine::mouse_center_flagged;bool Engine::mouse_center_flagged_laststep;keymap *Engine::keymaps;keymap *Engine::keydownmaps;keymap *Engine::keyupmaps;objfunc Engine::beginStepEvent;objfunc Engine::stepEvent;objfunc Engine::endStepEvent;instancemap *Engine::instances;collidemap *Engine::collisionmap;float Engine::mouse_x;float Engine::mouse_y;float Engine::r;float Engine::g;float Engine::b;void Engine::init() { Engine::currentRoom = NULL;        instanceref = *(new vector<Object *>());        objectref = *(new vector<ObjectType *>());        imageref = *(new vector<Image *>());        roomref = *(new vector<Room *>());        instances = new instancemap();        instances->insert(pair<int,objlist *>(0,new objlist()));        instances->insert(pair<int,objlist *>(1,new objlist()));        instances->insert(pair<int,objlist *>(2,new objlist()));        fillObjects();        fillImages();        fillRooms();        collisionmap = new collidemap();        registerCollisions();        mouse_left_flagged = false;        mouse_left_flagged_laststep = false;        mouse_right_flagged = false;        mouse_right_flagged_laststep = false;        mouse_center_flagged = false;        mouse_center_flagged_laststep = false;        keys = new keyhitmap();        keyslaststep = new keyhitmap();        keymaps = new keymap();        keydownmaps = new keymap();        keyupmaps = new keymap();        generateFunctionMaps(); r = 0; g = 0; b = 0;}void Engine::fillObjects() { /* -- CREATE OBJECT TYPES -- */}void Engine::fillImages() { /* -- CREATE IMAGES -- */}void Engine::fillRooms() { /* -- CREATE ROOMS -- */ if (roomref.size() > 0) {          Engine::currentRoom = roomref[0];  Engine::currentRoom->create(); }}void Engine::registerCollisions() {        collisionmap->insert(pair<ObjectType *,ObjectType *>(objectref[0],objectref[1]));}void Engine::handleEvents() {        vector<Object *> instances = Engine::currentRoom->getInstances();        unsigned int i;\n        //int j;\n        keyhitmap::iterator itor = keys->begin();        while (itor != keys->end()) {                bool val = (*itor).second;                int id = (*itor).first;                if (val == true) {                        objfunc function = (*(keymaps->find(id))).second;                        if (function != NULL) {                                for (i=0;i<instances.size();i++) {                                        Object *inst = instances[i];     if (inst != NULL) {                                         (inst->*function)();     }                                }                        }                }                itor ++;        }\n // left button\n if (mouse_left_flagged && !mouse_left_flagged_laststep) {  for (i=0;i<instances.size();i++) {                 Object *inst = instances[i];   if (inst != NULL) {    if (inst->pointInside(Engine::mouse_x,Engine::mouse_y)) {                          inst->mousepressed_left();    }    inst->globalmousepressed_left();   }                } } if (mouse_left_flagged) {  for (i=0;i<instances.size();i++) {                 Object *inst = instances[i];   if (inst != NULL) {   }                } } if (!mouse_left_flagged && mouse_left_flagged_laststep) {  for (i=0;i<instances.size();i++) {                 Object *inst = instances[i];   if (inst != NULL) {   }                } }\n // right button\n if (mouse_right_flagged && !mouse_right_flagged_laststep) {  for (i=0;i<instances.size();i++) {                 Object *inst = instances[i];   if (inst != NULL) {    if (inst->pointInside(Engine::mouse_x,Engine::mouse_y)) {                          inst->mousepressed_right();    }    inst->globalmousepressed_right();   }                } } if (mouse_right_flagged) {  for (i=0;i<instances.size();i++) {                 Object *inst = instances[i];   if (inst != NULL) {\n                         //inst->mouseclicked_right();\n   }                } } if (!mouse_right_flagged && mouse_right_flagged_laststep) {  for (i=0;i<instances.size();i++) {                 Object *inst = instances[i];   if (inst != NULL) {\n                         //inst->mousereleased_right();\n   }                } }\n // middle button\n if (mouse_center_flagged && !mouse_center_flagged_laststep) {  for (i=0;i<instances.size();i++) {                 Object *inst = instances[i];   if (inst != NULL) {    if (inst->pointInside(Engine::mouse_x,Engine::mouse_y)) {                          inst->mousepressed_middle();    }    inst->globalmousepressed_middle();   }                } } if (mouse_center_flagged) {  for (i=0;i<instances.size();i++) {                 Object *inst = instances[i];   if (inst != NULL) {\n                         //inst->mouseclicked_middle();\n   }                } } if (!mouse_center_flagged && mouse_center_flagged_laststep) {  for (i=0;i<instances.size();i++) {                 Object *inst = instances[i];   if (inst != NULL) {\n                         //inst->mousereleased_middle();\n   }                } }        itor = keys->begin();        keyhitmap::iterator itor2 = keyslaststep->begin();        while (itor != keys->end()) {                (*itor2).second = (*itor).second;                (*itor).second = false;                itor ++;                itor2 ++;        }        mouse_left_flagged_laststep = mouse_left_flagged;        mouse_right_flagged_laststep = mouse_right_flagged;        mouse_center_flagged_laststep = mouse_center_flagged;}void Engine::beginStep() {        vector<Object *> instances = Engine::currentRoom->getInstances();        unsigned int i;        for (i=0;i<instances.size();i++) {                Object *inst = instances[i];  if (inst != NULL) {                 inst->step_begin();  }        }}void Engine::step() {        vector<Object *> instances = Engine::currentRoom->getInstances();        unsigned int i;        for (i=0;i<instances.size();i++) {                Object *inst = instances[i];  if (inst != NULL) {                 inst->step();  }        }}void Engine::endStep() {        vector<Object *> instances = Engine::currentRoom->getInstances();        unsigned int i;        for (i=0;i<instances.size();i++) {                Object *inst = instances[i];  if (inst != NULL) {                 inst->step_end();  } }}void Engine::checkCollisions() {        collidemap::iterator it;        unsigned int i;        for (it=collisionmap->begin();it!=collisionmap->end();it++) {                objlist *list = Engine::instances->find((*it).first->getId())->second;                for (i=0;i<list->size();i++) {                        if (list->at(i)->check_collision_with_object((*it).second->getId())) {                                list->at(i)->collide_with((*it).second->getId());                        }                }        }}ObjectType *Engine::getObject(unsigned int id) {        if (id >= objectref.size()) {                return NULL;        }        return objectref[id];}Object *Engine::getInstance(unsigned int id) {        if (id >= instanceref.size()) {                return NULL;        }        return instanceref[id];}Image *Engine::getSprite(unsigned int id) {        if (id >= imageref.size()) {                return NULL;        }        return imageref[id];}Room *Engine::getRoom(unsigned int id) {        if (id >= roomref.size()) {                return NULL;        }        return roomref[id];}void Engine::setMouse(int x, int y) { Engine::mouse_x = x; Engine::mouse_y = y;}void Engine::setColors(float r, float g, float b) { Engine::r = r; Engine::g = g; Engine::b = b;}void Engine::generateFunctionMaps() {\n        //keys = new keyhitmap();\n\n        //keyslaststep = new keyhitmap();\n\n        //keymaps = new keymap();\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F1+200,&Object::key_F1));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F1+200,&Object::keydown_F1));        keys->insert(pair<int,bool>(GLUT_KEY_F1+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F1+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F2+200,&Object::key_F2));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F2+200,&Object::keydown_F2));        keys->insert(pair<int,bool>(GLUT_KEY_F2+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F2+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F3+200,&Object::key_F3));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F3+200,&Object::keydown_F3));        keys->insert(pair<int,bool>(GLUT_KEY_F3+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F3+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F4+200,&Object::key_F4));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F4+200,&Object::keydown_F4));        keys->insert(pair<int,bool>(GLUT_KEY_F4+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F4+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F5+200,&Object::key_F5));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F5+200,&Object::keydown_F5));        keys->insert(pair<int,bool>(GLUT_KEY_F5+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F5+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F6+200,&Object::key_F6));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F6+200,&Object::keydown_F6));        keys->insert(pair<int,bool>(GLUT_KEY_F6+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F6+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F7+200,&Object::key_F7));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F7+200,&Object::keydown_F7));        keys->insert(pair<int,bool>(GLUT_KEY_F7+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F7+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F8+200,&Object::key_F8));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F8+200,&Object::keydown_F8));        keys->insert(pair<int,bool>(GLUT_KEY_F8+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F8+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F9+200,&Object::key_F9));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F9+200,&Object::keydown_F9));        keys->insert(pair<int,bool>(GLUT_KEY_F9+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F9+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F10+200,&Object::key_F10));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F10+200,&Object::keydown_F10));        keys->insert(pair<int,bool>(GLUT_KEY_F10+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F10+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F11+200,&Object::key_F11));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F11+200,&Object::keydown_F11));        keys->insert(pair<int,bool>(GLUT_KEY_F11+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F11+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F12+200,&Object::key_F12));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F12+200,&Object::keydown_F12));        keys->insert(pair<int,bool>(GLUT_KEY_F12+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F12+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_UP+200,&Object::key_up));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_UP+200,&Object::keydown_up));        keys->insert(pair<int,bool>(GLUT_KEY_UP+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_UP+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_DOWN+200,&Object::key_down));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_DOWN+200,&Object::keydown_down));        keys->insert(pair<int,bool>(GLUT_KEY_DOWN+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_DOWN+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_LEFT+200,&Object::key_left));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_LEFT+200,&Object::keydown_left));        keys->insert(pair<int,bool>(GLUT_KEY_LEFT+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_LEFT+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_RIGHT+200,&Object::key_right));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_RIGHT+200,&Object::keydown_right));        keys->insert(pair<int,bool>(GLUT_KEY_RIGHT+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_RIGHT+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_PAGE_UP+200,&Object::key_page_up));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_PAGE_UP+200,&Object::keydown_page_up));        keys->insert(pair<int,bool>(GLUT_KEY_PAGE_UP+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_PAGE_UP+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_PAGE_DOWN+200,&Object::key_page_down));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_PAGE_DOWN+200,&Object::keydown_page_down));        keys->insert(pair<int,bool>(GLUT_KEY_PAGE_DOWN+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_PAGE_DOWN+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_HOME+200,&Object::key_home));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_HOME+200,&Object::keydown_home));        keys->insert(pair<int,bool>(GLUT_KEY_HOME+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_HOME+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_END+200,&Object::key_end));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_END+200,&Object::keydown_end));        keys->insert(pair<int,bool>(GLUT_KEY_END+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_END+200,false));        keymaps->insert(pair<int,objfunc>(GLUT_KEY_INSERT+200,&Object::key_insert));        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_INSERT+200,&Object::keydown_insert));        keys->insert(pair<int,bool>(GLUT_KEY_INSERT+200,false));        keyslaststep->insert(pair<int,bool>(GLUT_KEY_INSERT+200,false));        keymaps->insert(pair<int,objfunc>('a',&Object::key_a));        keys->insert(pair<int,bool>('a',false));        keyslaststep->insert(pair<int,bool>('a',false));        keymaps->insert(pair<int,objfunc>('b',&Object::key_b));        keys->insert(pair<int,bool>('b',false));        keyslaststep->insert(pair<int,bool>('b',false));        keymaps->insert(pair<int,objfunc>('c',&Object::key_c));        keys->insert(pair<int,bool>('c',false));        keyslaststep->insert(pair<int,bool>('c',false));        keymaps->insert(pair<int,objfunc>('d',&Object::key_d));        keys->insert(pair<int,bool>('d',false));        keyslaststep->insert(pair<int,bool>('d',false));        keymaps->insert(pair<int,objfunc>('e',&Object::key_e));        keys->insert(pair<int,bool>('e',false));        keyslaststep->insert(pair<int,bool>('e',false));        keymaps->insert(pair<int,objfunc>('f',&Object::key_f));        keys->insert(pair<int,bool>('f',false));        keyslaststep->insert(pair<int,bool>('f',false));        keymaps->insert(pair<int,objfunc>('g',&Object::key_g));        keys->insert(pair<int,bool>('g',false));        keyslaststep->insert(pair<int,bool>('g',false));        keymaps->insert(pair<int,objfunc>('h',&Object::key_h));        keys->insert(pair<int,bool>('h',false));        keyslaststep->insert(pair<int,bool>('h',false));        keymaps->insert(pair<int,objfunc>('i',&Object::key_i));        keys->insert(pair<int,bool>('i',false));        keyslaststep->insert(pair<int,bool>('i',false));        keymaps->insert(pair<int,objfunc>('j',&Object::key_j));        keys->insert(pair<int,bool>('j',false));        keyslaststep->insert(pair<int,bool>('j',false));        keymaps->insert(pair<int,objfunc>('k',&Object::key_k));        keys->insert(pair<int,bool>('k',false));        keyslaststep->insert(pair<int,bool>('k',false));        keymaps->insert(pair<int,objfunc>('l',&Object::key_l));        keys->insert(pair<int,bool>('l',false));        keyslaststep->insert(pair<int,bool>('l',false));        keymaps->insert(pair<int,objfunc>('m',&Object::key_m));        keys->insert(pair<int,bool>('m',false));        keyslaststep->insert(pair<int,bool>('m',false));        keymaps->insert(pair<int,objfunc>('n',&Object::key_n));        keys->insert(pair<int,bool>('n',false));        keyslaststep->insert(pair<int,bool>('n',false));        keymaps->insert(pair<int,objfunc>('o',&Object::key_o));        keys->insert(pair<int,bool>('o',false));        keyslaststep->insert(pair<int,bool>('o',false));        keymaps->insert(pair<int,objfunc>('p',&Object::key_p));        keys->insert(pair<int,bool>('p',false));        keyslaststep->insert(pair<int,bool>('p',false));        keymaps->insert(pair<int,objfunc>('q',&Object::key_q));        keys->insert(pair<int,bool>('q',false));        keyslaststep->insert(pair<int,bool>('q',false));        keymaps->insert(pair<int,objfunc>('r',&Object::key_r));        keys->insert(pair<int,bool>('r',false));        keyslaststep->insert(pair<int,bool>('r',false));        keymaps->insert(pair<int,objfunc>('s',&Object::key_s));        keys->insert(pair<int,bool>('s',false));        keyslaststep->insert(pair<int,bool>('s',false));        keymaps->insert(pair<int,objfunc>('t',&Object::key_t));        keys->insert(pair<int,bool>('t',false));        keyslaststep->insert(pair<int,bool>('t',false));        keymaps->insert(pair<int,objfunc>('u',&Object::key_u));        keys->insert(pair<int,bool>('u',false));        keyslaststep->insert(pair<int,bool>('u',false));        keymaps->insert(pair<int,objfunc>('v',&Object::key_v));        keys->insert(pair<int,bool>('v',false));        keyslaststep->insert(pair<int,bool>('v',false));        keymaps->insert(pair<int,objfunc>('w',&Object::key_w));        keys->insert(pair<int,bool>('w',false));        keyslaststep->insert(pair<int,bool>('w',false));        keymaps->insert(pair<int,objfunc>('x',&Object::key_x));        keys->insert(pair<int,bool>('x',false));        keyslaststep->insert(pair<int,bool>('x',false));        keymaps->insert(pair<int,objfunc>('y',&Object::key_y));        keys->insert(pair<int,bool>('y',false));        keyslaststep->insert(pair<int,bool>('y',false));        keymaps->insert(pair<int,objfunc>('z',&Object::key_z));        keys->insert(pair<int,bool>('z',false));        keyslaststep->insert(pair<int,bool>('z',false));        beginStepEvent = &Object::step_begin;        stepEvent = &Object::step;        endStepEvent = &Object::step_end;}";
files.insert(pair<string,string*>("Engine_cpp",&Engine_cpp));
Objects_h = "\n#ifndef OBJECTSH\n\n#define OBJECTSH\n\n#include \"Object.h\"\n/* -- OBJECT INCLUDES -- */\n#endif\n";
files.insert(pair<string,string*>("Objects_h",&Objects_h));
Room_cpp = "\n#include \"Room.h\"\nRoom::Room(int i, string t, int w, int h, int sp) {        id = i;        title = t;        width = w;        height = h;        speed = sp;        instances = *(new vector<Object *>());}void Room::initInstances() {}void Room::create() {}void Room::draw() {        unsigned int i;        for (i=0;i<instances.size();i++) {  if (instances[i] != NULL) {                 instances[i]->draw();  }        }}";
files.insert(pair<string,string*>("Room_cpp",&Room_cpp));
Image_h = "/* Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above notice and this permission notice shall be included in all copies * or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. *//* File for \"Putting It All Together\" lesson of the OpenGL tutorial on * www.videotutorialsrock.com */\n#ifndef IMAGE_LOADER_H_INCLUDED\n\n#define IMAGE_LOADER_H_INCLUDED\n\n#ifdef __APPLE__\n\n#include <OpenGL/OpenGL.h>\n\n#include <GLUT/glut.h>\n\n#else\n\n#include <GL/glut.h>\n\n#endif\n\n#define IMAGE_FILE 1\n\n#define IMAGE_DATA 2\n\n//Represents an image\nclass Image { public:  void loadBMP(char* filename);  Image(char* ps);  Image(char* ps, float,float,int);  ~Image();    /* An array of the form (R1, G1, B1, R2, G2, B2, ...) indicating the   * color of each pixel in image.  Color components range from 0 to 255.   * The array starts the bottom-left pixel, then moves right to the end   * of the row, then moves up to the next column, and so on.  This is the   * format in which OpenGL likes images.   */  char* pixels;  float width;  float height;  float dheight;  float dwidth;                int *blocked;  GLuint _textureId;  void draw(float,float);  GLuint loadTexture(char *);        private:                void computeBlocked();};\n#endif\n";
files.insert(pair<string,string*>("Image_h",&Image_h));
Makefile = "\nCC = g++\n\nCFLAGS = -Wall -g\n\nPROG = game\n\nCORE_FILES = Engine.cpp Engine.h Image.cpp Image.h ObjectType.cpp ObjectType.h Object.cpp Object.h Objects.h Room.cpp Room.h Rooms.h common.cpp common.h main.cpp\n\nEXTRA_FILES = \n\n\n\n\n\nifeq ($(shell uname),Darwin)\n\n	LIBS = -framework OpenGL -framework GLUT\n\nelse\n\n	LIBS = -lglut\n\nendif\n\n\n\nall:\n\n	$(CC) $(LIBS) $(CFLAGS) -o $(PROG) $(CORE_FILES) $(EXTRA_FILES)\n\n\n\nclean:\n\n	rm -f $(CORE_FILES) $(EXTRA_FILES)\n\n\n\n\n";
files.insert(pair<string,string*>("Makefile",&Makefile));
ObjectType_h = "\n#ifndef OBJECTTYPEH\n\n#define OBJECTTYPEH\n\n#include <string>\nusing namespace std;class ObjectType {public: ObjectType(int i,string s, int im); string getName() {return name;} int getId() {return id;} int getSprite() {return sprite;}private: string name; int id; int sprite;};\n#endif\n";
files.insert(pair<string,string*>("ObjectType_h",&ObjectType_h));
Rooms_h = "\n#ifndef ROOMSH\n\n#define ROOMSH\n\n#include \"Room.h\"\n/* -- ROOM INCLUDES -- */\n#endif\n";
files.insert(pair<string,string*>("Rooms_h",&Rooms_h));
Engine_h = "\n#ifndef ENGINE\n\n#define ENGINE\n\n#define noone -4\n\n#include \"Objects.h\"\n\n#include <vector>\n\n#include \"Image.h\"\n\n#include \"ObjectType.h\"\n\n#include \"Room.h\"\n\n#include <map>\n\n#include <iostream>\nusing namespace std;\n#ifdef __APPLE__\n\n#include <OpenGL/OpenGL.h>\n\n#include <GLUT/glut.h>\n\n#else\n\n#include <GL/glut.h>\n\n#endif\nusing namespace std;typedef void (Object::*objfunc)();typedef map<int,objfunc> keymap;typedef map<int,bool> keyhitmap;typedef vector<Object *> objlist;typedef map<int,objlist *> instancemap;typedef map<ObjectType *,ObjectType *> collidemap;class Engine {public:        static void init();        static void fillObjects();        static void fillImages();        static void fillRooms();        static void registerCollisions();        static void generateFunctionMaps();        static void handleEvents();        static void beginStep();        static void step();        static void endStep();        static void checkCollisions();        static vector<ObjectType *> objectref;        static vector<Image *> imageref;        static vector<Object *> instanceref;        static vector<Room *> roomref;\n        //static bool keys[500];\n        static keyhitmap *keys;\n        //static bool keyslaststep[500];\n        static keyhitmap *keyslaststep;        static objfunc beginStepEvent;        static objfunc stepEvent;        static objfunc endStepEvent;        static int instanceid;        static ObjectType *getObject(unsigned int id);        static Object *getInstance(unsigned int id);        static Image *getSprite(unsigned int id);        static Room *getRoom(unsigned int id);        static Room *currentRoom;        static bool mouse_left_flagged;        static bool mouse_left_flagged_laststep;        static bool mouse_right_flagged;        static bool mouse_right_flagged_laststep;        static bool mouse_center_flagged;        static bool mouse_center_flagged_laststep; static float mouse_x; static float mouse_y; static void setMouse(int x, int y);                static keymap *keymaps; static keymap *keydownmaps;        static keymap *keyupmaps; static float r; static float g; static float b; static void setColors(float,float,float);        static instancemap *instances;        static collidemap *collisionmap;};\n#endif\n";
files.insert(pair<string,string*>("Engine_h",&Engine_h));
Image_cpp = "/* Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: *  * The above notice and this permission notice shall be included in all copies * or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. *//* File for \"Putting It All Together\" lesson of the OpenGL tutorial on * www.videotutorialsrock.com */\n#include <assert.h>\n\n#include <fstream>\n\n#include <iostream>\n\n#include <cstdlib>\n\n#include \"Image.h\"\n\n#ifdef __APPLE__\n\n#include <OpenGL/OpenGL.h>\n\n#include <GLUT/glut.h>\n\n#else\n\n#include <GL/glut.h>\n\n#endif\nusing namespace std;GLuint Image::loadTexture(char *pixels) { GLuint textureId; glGenTextures(1, &textureId); glBindTexture(GL_TEXTURE_2D, textureId); glTexImage2D(GL_TEXTURE_2D,     0,     GL_RGB,     width, height,     0,     GL_RGB,     GL_UNSIGNED_BYTE,     pixels); return textureId;}Image::Image(char* filename) { loadBMP(filename); _textureId = loadTexture(pixels);        computeBlocked();}Image::Image(char* filename, float w, float h, int type) { if (type == IMAGE_FILE) {  loadBMP(filename);\n  //width = w;\n\n  //height = h;\n  _textureId = loadTexture(pixels);                computeBlocked();  width = w;  height = h;  dwidth = w;  dheight = h; } else if (type == IMAGE_DATA) {  pixels = filename;  width = w;  height = h;  _textureId = loadTexture(pixels);  dwidth = w;  dheight = h;                computeBlocked(); }}Image::~Image() { delete[] pixels;}void Image::draw(float x, float y) { if (!(width != dwidth || height != dheight)) {\n //if ((int)dwidth % 2 != 0 || (int)dheight % 2 != 0) {\n  glTranslatef(x, y, 0.0f);  glEnable(GL_TEXTURE_2D);  glBindTexture(GL_TEXTURE_2D, _textureId);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);  glColor3f(1.0f, 1.0f, 1.0f);  glBegin(GL_QUADS);  glNormal3f(0.0, 0.0f, 1.0f);  glTexCoord2f(0.0f, 0.0f);  glVertex2f(0,0);  glTexCoord2f(1.0f, 0.0f);  glVertex2f(dwidth, 0);  glTexCoord2f(1.0f, -1.0f);  glVertex2f(dwidth, dheight);  glTexCoord2f(0.0f, -1.0f);  glVertex2f(0, dheight);  glEnd();  glDisable(GL_TEXTURE_2D); } else {  glRasterPos2f(x+1,y+16);  glDrawPixels(width,height,GL_RGB,GL_UNSIGNED_BYTE,pixels); }}namespace {\n //Converts a four-character array to an integer, using little-endian form\n int toInt(const char* bytes) {  return (int)(((unsigned char)bytes[3] << 24) |      ((unsigned char)bytes[2] << 16) |      ((unsigned char)bytes[1] << 8) |      (unsigned char)bytes[0]); } \n //Converts a two-character array to a short, using little-endian form\n short toShort(const char* bytes) {  return (short)(((unsigned char)bytes[1] << 8) |        (unsigned char)bytes[0]); } \n //Reads the next four bytes as an integer, using little-endian form\n int readInt(ifstream &input) {  char buffer[4];  input.read(buffer, 4);  return toInt(buffer); } \n //Reads the next two bytes as a short, using little-endian form\n short readShort(ifstream &input) {  char buffer[2];  input.read(buffer, 2);  return toShort(buffer); } \n //Just like auto_ptr, but for arrays\n template<class T> class auto_array {  private:   T* array;   mutable bool isReleased;  public:   explicit auto_array(T* array_ = NULL) :    array(array_), isReleased(false) {   }      auto_array(const auto_array<T> &aarray) {    array = aarray.array;    isReleased = aarray.isReleased;    aarray.isReleased = true;   }      ~auto_array() {    if (!isReleased && array != NULL) {     delete[] array;    }   }      T* get() const {    return array;   }      T &operator*() const {    return *array;   }      void operator=(const auto_array<T> &aarray) {    if (!isReleased && array != NULL) {     delete[] array;    }    array = aarray.array;    isReleased = aarray.isReleased;    aarray.isReleased = true;   }      T* operator->() const {    return array;   }      T* release() {    isReleased = true;    return array;   }      void reset(T* array_ = NULL) {    if (!isReleased && array != NULL) {     delete[] array;    }    array = array_;   }      T* operator+(int i) {    return array + i;   }      T &operator[](int i) {    return array[i];   } };}void Image::loadBMP(char* filename) { ifstream input; input.open(filename, ifstream::binary); assert(!input.fail() || !\"Could not find file\"); char buffer[2]; input.read(buffer, 2); assert((buffer[0] == 'B' && buffer[1] == 'M') || !\"Not a bitmap file\"); input.ignore(8); int dataOffset = readInt(input); \n //Read the header\n int headerSize = readInt(input); int width; int height; switch(headerSize) {  case 40:\n   //V3\n   width = readInt(input);   height = readInt(input);   input.ignore(2);   assert(readShort(input) == 24 || !\"Image is not 24 bits per pixel\");   assert(readShort(input) == 0 || !\"Image is compressed\");   break;  case 12:\n   //OS/2 V1\n   width = readShort(input);   height = readShort(input);   input.ignore(2);   assert(readShort(input) == 24 || !\"Image is not 24 bits per pixel\");   break;  case 64:\n   //OS/2 V2\n   assert(!\"Can't load OS/2 V2 bitmaps\");   break;  case 108:\n   //Windows V4\n   assert(!\"Can't load Windows V4 bitmaps\");   break;  case 124:\n   //Windows V5\n   assert(!\"Can't load Windows V5 bitmaps\");   break;  default:   assert(!\"Unknown bitmap format\"); } \n //Read the data\n int bytesPerRow = ((width * 3 + 3) / 4) * 4 - (width * 3 % 4); int size = bytesPerRow * height; auto_array<char> pixels(new char[size]); input.seekg(dataOffset, ios_base::beg); input.read(pixels.get(), size); \n //Get the data into the right format\n auto_array<char> pixels2(new char[width * height * 3]); for(int y = 0; y < height; y++) {  for(int x = 0; x < width; x++) {   for(int c = 0; c < 3; c++) {    pixels2[3 * (width * y + x) + c] =     pixels[bytesPerRow * y + 3 * x + (2 - c)];   }  } }  input.close();\n //return new Image(pixels2.release(), width, height);\n this->width = width; this->height = height;\n //return pixels2.release();\n this->pixels = pixels2.release();}void Image::computeBlocked() {        blocked = (int *)malloc(sizeof(int)*width*height);        float r,g,b,rt,gt,bt;        int i,j;        r = pixels[((int)height-1)*(int)width*3];        g = pixels[((int)height-1)*(int)width*3+1];        b = pixels[((int)height-1)*(int)width*3+2];        for (i=0;i<height;i++) {                for (j=0;j<width;j++) {                        rt = pixels[i*(int)width+j*3];                        gt = pixels[i*(int)width+j*3+1];                        bt = pixels[i*(int)width+j*3+2];                        if (rt == r && gt == g && bt == b) {                                blocked[i*(int)width+j] = 1;                        } else {                                blocked[i*(int)width+j] = 0;                        }                }        }}";
files.insert(pair<string,string*>("Image_cpp",&Image_cpp));
Object_cpp = "\n#include \"ObjectType.h\"\n\n#include \"Object.h\"\n\n#include <string>\n\n#include \"common.h\"\n\n#ifdef __APPLE__\n\n#include <OpenGL/OpenGL.h>\n\n#include <GLUT/glut.h>\n\n#else\n\n#include <GL/glut.h>\n\n#endif\nusing namespace std;Object::Object(int i, ObjectType *obj, float xx, float yy) { id = i; sprite = obj->getSprite();        type = obj;        x = xx;        y = yy;        create();}void Object::create() {}void Object::destroy() {}void Object::draw() { if (sprite != noone) {                draw_sprite(sprite,0,x,y); }}void Object::key_up() {}void Object::key_down() {}void Object::key_left() {}void Object::key_right() {}void Object::key_F1() {}void Object::key_F2() {}void Object::key_F3() {}void Object::key_F4() {}void Object::key_F5() {}void Object::key_F6() {}void Object::key_F7() {}void Object::key_F8() {}void Object::key_F9() {}void Object::key_F10() {}void Object::key_F11() {}void Object::key_F12() {}void Object::key_page_down() {}void Object::key_page_up() {}void Object::key_home() {}void Object::key_end() {}void Object::key_insert() {}void Object::key_a() {}void Object::key_b() {}void Object::key_c() {}void Object::key_d() {}void Object::key_e() {}void Object::key_f() {}void Object::key_g() {}void Object::key_h() {}void Object::key_i() {}void Object::key_j() {}void Object::key_k() {}void Object::key_l() {}void Object::key_m() {}void Object::key_n() {}void Object::key_o() {}void Object::key_p() {}void Object::key_q() {}void Object::key_r() {}void Object::key_s() {}void Object::key_t() {}void Object::key_u() {}void Object::key_v() {}void Object::key_w() {}void Object::key_x() {}void Object::key_y() {}void Object::key_z() {}void Object::keyup_up() {}void Object::keyup_down() {}void Object::keyup_left() {}void Object::keyup_right() {}void Object::keyup_F1() {}void Object::keyup_F2() {}void Object::keyup_F3() {}void Object::keyup_F4() {}void Object::keyup_F5() {}void Object::keyup_F6() {}void Object::keyup_F7() {}void Object::keyup_F8() {}void Object::keyup_F9() {}void Object::keyup_F10() {}void Object::keyup_F11() {}void Object::keyup_F12() {}void Object::keyup_page_down() {}void Object::keyup_page_up() {}void Object::keyup_home() {}void Object::keyup_end() {}void Object::keyup_insert() {}void Object::keydown_up() {}void Object::keydown_down() {}void Object::keydown_left() {}void Object::keydown_right() {}void Object::keydown_F1() {}void Object::keydown_F2() {}void Object::keydown_F3() {}void Object::keydown_F4() {}void Object::keydown_F5() {}void Object::keydown_F6() {}void Object::keydown_F7() {}void Object::keydown_F8() {}void Object::keydown_F9() {}void Object::keydown_F10() {}void Object::keydown_F11() {}void Object::keydown_F12() {}void Object::keydown_page_down() {}void Object::keydown_page_up() {}void Object::keydown_home() {}void Object::keydown_end() {}void Object::keydown_insert() {}void Object::mousepressed_left() {}void Object::mousepressed_right() {}void Object::mousepressed_middle() {}void Object::globalmousepressed_left() {}void Object::globalmousepressed_right() {}void Object::globalmousepressed_middle() {}void Object::step_begin() {}void Object::step() {}void Object::step_end() {}int Object::getType() {        return type->getId();}string Object::getName() {        return type->getName();}bool Object::check_collision_with_object(int objectId) {        return false;}void Object::collide_with(int objectId) {        }bool Object::pointInside(float px, float py) { if (Engine::getSprite(type->getSprite()) == NULL) {  return false; } float width = Engine::getSprite(type->getSprite())->width; float height = Engine::getSprite(type->getSprite())->height; return (px >= x && px <= x+width && py >= y && py <= y+height);}";
files.insert(pair<string,string*>("Object_cpp",&Object_cpp));
Object_h = "\n#ifndef OBJECTH\n\n#define OBJECTH\n\n#include <string>\n\n#include <map>\n\n#include \"Image.h\"\n\n#include \"ObjectType.h\"\nusing namespace std;class Object {public: Object(int i, ObjectType *obj, float x, float y); virtual void create(); virtual void destroy(); virtual void draw();        virtual void key_up();        virtual void key_down();        virtual void key_left();        virtual void key_right();        virtual void key_F1();        virtual void key_F2();        virtual void key_F3();        virtual void key_F4();        virtual void key_F5();        virtual void key_F6();        virtual void key_F7();        virtual void key_F8();        virtual void key_F9();        virtual void key_F10();        virtual void key_F11();        virtual void key_F12();        virtual void key_page_down();        virtual void key_page_up();        virtual void key_home();        virtual void key_end();        virtual void key_insert(); virtual void key_a(); virtual void key_b(); virtual void key_c(); virtual void key_d(); virtual void key_e(); virtual void key_f(); virtual void key_g(); virtual void key_h(); virtual void key_i(); virtual void key_j(); virtual void key_k(); virtual void key_l(); virtual void key_m(); virtual void key_n(); virtual void key_o(); virtual void key_p(); virtual void key_q(); virtual void key_r(); virtual void key_s(); virtual void key_t(); virtual void key_u(); virtual void key_v(); virtual void key_w(); virtual void key_x(); virtual void key_y(); virtual void key_z(); virtual void keyup_up();        virtual void keyup_down();        virtual void keyup_left();        virtual void keyup_right();        virtual void keyup_F1();        virtual void keyup_F2();        virtual void keyup_F3();        virtual void keyup_F4();        virtual void keyup_F5();        virtual void keyup_F6();        virtual void keyup_F7();        virtual void keyup_F8();        virtual void keyup_F9();        virtual void keyup_F10();        virtual void keyup_F11();        virtual void keyup_F12();        virtual void keyup_page_down();        virtual void keyup_page_up();        virtual void keyup_home();        virtual void keyup_end();        virtual void keyup_insert();        virtual void keydown_up();        virtual void keydown_down();        virtual void keydown_left();        virtual void keydown_right();        virtual void keydown_F1();        virtual void keydown_F2();        virtual void keydown_F3();        virtual void keydown_F4();        virtual void keydown_F5();        virtual void keydown_F6();        virtual void keydown_F7();        virtual void keydown_F8();        virtual void keydown_F9();        virtual void keydown_F10();        virtual void keydown_F11();        virtual void keydown_F12();        virtual void keydown_page_down();        virtual void keydown_page_up();        virtual void keydown_home();        virtual void keydown_end();        virtual void keydown_insert(); virtual void mousepressed_left(); virtual void mousepressed_right(); virtual void mousepressed_middle(); virtual void globalmousepressed_left(); virtual void globalmousepressed_right(); virtual void globalmousepressed_middle();        virtual void step_begin();        virtual void step();        virtual void step_end(); string getName(); int getId() {return id;} int getSprite() {return sprite;}        int getType();        bool check_collision_with_object(int objectId);        virtual void collide_with(int instanceId); int id; int sprite;        float x;        float y;        ObjectType *type; bool pointInside(float x, float y);};\n#endif\n";
files.insert(pair<string,string*>("Object_h",&Object_h));
ObjectType_cpp = "\n#include \"ObjectType.h\"\n\n#include <string>\nusing namespace std;ObjectType::ObjectType(int i, string s, int im) { id = i; name = s; sprite = im;}";
files.insert(pair<string,string*>("ObjectType_cpp",&ObjectType_cpp));
Room_h = "\n#ifndef ROOMH\n\n#define ROOMH\n\n#include <vector>\n\n#include <string>\nusing namespace std;\n#include \"Objects.h\"\nclass Room {public: Room(int i, string t, int w, int h, int sp = 30);        virtual void initInstances(); virtual void create(); void draw(); string getTitle() {return title;} int getId() {return id;}        int getWidth() {return width;}        int getheight() {return height;}        vector<Object *> getInstances() {return instances;}        int getSpeed() {return speed;} int id; string title;        int width;        int height;        vector<Object *> instances;        int speed; float r; float g; float b;};\n#endif\n";
files.insert(pair<string,string*>("Room_h",&Room_h));
common_cpp = "\n#include \"common.h\"\nint instance_create(unsigned int id, int x, int y) {        int ret = noone;        Object *inst = NULL;        ObjectType *object= Engine::objectref[id]; /* -- OBJECT CREATION -- */        if (inst != NULL) {                Engine::instanceref.push_back(inst);                Engine::instances->find(id)->second->push_back(inst);  if (Engine::currentRoom != NULL) {   Engine::currentRoom->instances.push_back(inst);  }                ret = Engine::instanceid;                Engine::instanceid++;        }        return ret;}void draw_sprite(unsigned int sprite, int offset, float x, float y) {        if (sprite >= Engine::imageref.size()) {                return;        }        Engine::imageref[sprite]->draw(x,y);}void draw_line(float x1, float y1, float x2, float y2) { glColor3f(Engine::r,Engine::g,Engine::b); glBegin(GL_LINES); glVertex2f(x1,y1); glVertex2f(x2,y2); glEnd();}int instance_number(int object) { instancemap::iterator itor = Engine::instances->find(object); if (itor == Engine::instances->end()) {  return 0; } return itor->second->size();}Object *instance_find(int object, int number) { instancemap::iterator itor = Engine::instances->find(object); if (itor == Engine::instances->end()) {  return 0; } objlist *list = itor->second; return list->at(number);}void draw_set_color_rgb(int r, int g, int b) { Engine::r = ((float)r)/255; Engine::g = ((float)g)/255; Engine::b = ((float)b)/255;}void draw_point(float x, float y) { glColor3f(Engine::r,Engine::g,Engine::b); glBegin(GL_POINTS); glVertex2f(x,y); glEnd();}";
files.insert(pair<string,string*>("common_cpp",&common_cpp));
}
