#include "files.h"
map<string,string *> files;
string main_cpp;
string Font_h;
string common_h;
string Font_cpp;
string sprites_cpp;
string Engine_cpp;
string sprites_h;
string Objects_h;
string Room_cpp;
string Image_h;
string Makefile;
string Rooms_h;
string Engine_h;
string Image_cpp;
string Variable_h;
string Object_cpp;
string Object_h;
string Variable_cpp;
string Room_h;
string common_cpp;
void initFiles() {
files = *(new map<string,string *>());
main_cpp = "#include <iostream>\n#include <stdlib.h>\n\n#ifdef __APPLE__\n#include <OpenGL/OpenGL.h>\n#include <GLUT/glut.h>\n#else\n#include <GL/glut.h>\n#endif\n\n#include \"Image.h\"\n#include \"Objects.h\"\n#include \"Room.h\"\n#include <cstdio>\n#include \"Engine.h\"\n#include \"Rooms.h\"\n#include <cstdlib>\n\nusing namespace std;\n\nconst float BOX_SIZE = 70.0f; //The length of each side of the cube\nconst float WINDOW_WIDTH = 800;\nconst float WINDOW_HEIGHT = 600;\n//testobject *inst;\n//int objectid;\n//int instanceid;\n\nvoid handleKeypress(unsigned char key, int x, int y) {\n        (*Engine::keys->find(key)).second = true;\n        //Engine::keys[key] = true;\n switch (key) {\n  case 27: //Escape key\n   exit(0);\n }\n}\n\n\nvoid handleMouse(int button, int state, int x, int y) {\n if (button == GLUT_LEFT_BUTTON) {\n  if (state == GLUT_DOWN) {\n   cout << \"main.cpp handleMouse\" << endl;\n   Engine::mouse_left_flagged = true;\n  } else if (state == GLUT_UP) {\n   Engine::mouse_left_flagged = false; \n  }\n } else if (button == GLUT_RIGHT_BUTTON) {\n  if (state == GLUT_DOWN) {\n   Engine::mouse_right_flagged = true;\n  } else if (state == GLUT_UP) {\n   Engine::mouse_right_flagged = false; \n  }\n } else if (button == GLUT_MIDDLE_BUTTON) {\n  if (state == GLUT_DOWN) {\n   Engine::mouse_center_flagged = true;\n  } else if (state == GLUT_UP) {\n   Engine::mouse_center_flagged = false; \n  }\n }\n Engine::setMouse(x,y);\n}\n\nvoid handleMouseMotion(int x, int y) {\n Engine::setMouse(x,y);\n}\n\nvoid handleSpecialKeypress(int key, int x, int y) {\n        (*Engine::keys->find(key+200)).second = true;\n}\n\nvoid initRendering() {\n\n glEnable(GL_DEPTH_TEST);\n glEnable(GL_LIGHTING);\n glEnable(GL_LIGHT0);\n glEnable(GL_NORMALIZE);\n glEnable(GL_COLOR_MATERIAL);\n glDisable(GL_CULL_FACE);\n\n cout << \"main.cpp initRendering initializing engine\" << endl;\n        Engine::init();\n}\n\nvoid handleResize(int w, int h) {\n cout << \"main.cpp handleResize begin\" << endl;\n glViewport(0, 0, w, h);\n glMatrixMode(GL_PROJECTION);\n glLoadIdentity();\n glOrtho(0,w,h,0,-100,1000);\n Engine::currentRoom->width = w;\n Engine::currentRoom->height = h;\n cout << \"main.cpp handleResize completed \" << endl;\n}\n\nvoid drawScene() {\n glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n \n glMatrixMode(GL_MODELVIEW);\n glLoadIdentity();\n\n glClearColor(Engine::currentRoom->r, Engine::currentRoom->g, Engine::currentRoom->b,0);\n\n        Engine::currentRoom->draw();\n \n glutSwapBuffers();\n}\n\nvoid update(int value) {\n        // begin step\n        Engine::beginStep();\n        // fire events\n        Engine::handleEvents();\n        // collision\n        Engine::checkCollisions();\n        // step\n        Engine::step();\n        // end step\n        Engine::endStep();\n        // draw\n glutPostRedisplay();\n glutTimerFunc(1000/Engine::currentRoom->getSpeed(), update, 0);\n}\n\nint main(int argc, char** argv) {\n glutInit(&argc, argv);\n glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);\n glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);\n\n cout << \"main.cpp main program entered\" << endl; \n\n glutCreateWindow(\"Game name!\");\n initRendering();\n\n        if (Engine::currentRoom == NULL) {\n                cout << \"No rooms defined.\" << endl;\n                exit(1);\n        }\n \n glutDisplayFunc(drawScene);\n glutKeyboardFunc(handleKeypress);\n glutSpecialFunc(handleSpecialKeypress);\n glutMouseFunc(handleMouse);\n glutMotionFunc(handleMouseMotion);\n glutPassiveMotionFunc(handleMouseMotion);\n glutReshapeFunc(handleResize);\n glutTimerFunc(1, update, 0);\n \n glutMainLoop();\n return 0;\n}\n\n\n\n\n\n\n\n\n\n\n";
files.insert(pair<string,string*>("main_cpp",&main_cpp));
Font_h = "#ifndef FONTH\n#define FONTH\n\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nclass Letter {\npublic:\n Letter(int,int,char *);\n int width;\n int height;\n char *pixels;\n};\n\nclass Font {\npublic:\n Font(const char *);\n map<char,Letter *> *letters;\n void create(const char *);\n int widthOf(char);\n vector<char> *chars;\n};\n\n#endif\n\n";
files.insert(pair<string,string*>("Font_h",&Font_h));
common_h = "#ifndef COMMONH\n#define COMMONH\n\n#include <vector>\n#include \"Engine.h\"\n#include <iostream>\n#include <string>\n\n/* -- OBJECT DEFINITIONS -- */\n\n#define c_white 1,1,1\n\n#define mouse_x Engine::mousex\n#define mouse_y Engine::mousey\n\n#define noone -4\n\n#define room_width Engine::currentRoom->width\n#define room_height Engine::currentRoom->height\n\n#define keyboard_string Engine::keyboardString\n\nusing namespace std;\n\nextern int instance_create(unsigned int id, int x, int y);\nextern void draw_sprite(unsigned int sprite, int offset, float x, float y);\nextern void draw_line(float x1, float y1, float x2, float y2);\nextern int instance_number(int object);\nextern int instance_find(int object, int number);\nextern void draw_set_color_rgb(int r, int g, int b);\nextern void draw_point(float x, float y);\nextern void draw_line_color(float x1, float y1, float x2, float y2, float r, float g, float b);\nextern void draw_text(string text, float x, float y);\nextern void draw_text(Variable *text, float x, float y);\nextern void draw_rectangle(float x1, float y1, float x2, float y2);\nextern void draw_rectangle_color(float x1, float y1, float x2, float y2, float r, float g, float b);\nextern void Tokenize(const string& str, vector<string>& tokens, const string& delimiters);\nextern int file_text_open_write(string filename);\nextern void file_text_close(int handle);\nextern int ds_list_create();\nextern void ds_list_add(Variable &id, Variable &value);\nextern void ds_list_add(Variable &id, const char*value);\nextern void ds_list_add(Variable &id, int value);\nextern Variable &ds_list_find_value(int id, int pos);\nextern int ds_list_size(int id);\nextern int round(Variable *);\n\n#endif\n\n";
files.insert(pair<string,string*>("common_h",&common_h));
Font_cpp = "#include <fstream>\n#include <cstdlib>\n#include <iostream>\n\n#include \"Font.h\"\n\nusing namespace std;\n\nFont::Font(const char *filename) {\n cout << \"font.cpp font creating new font \" << filename << endl;\n ifstream infile;\n infile.open(filename, ios::in | ios::binary);\n char c;\n Letter *letter;\n char w,h,ch;\n int i,j;\n letters = new map<char, Letter *>();\n chars = new vector<char>();\n while (infile.read(&c,1)) {\n  w = c;\n  infile.read(&h,1);\n  infile.read(&ch,1);\n  chars->push_back(ch);\n  char *p = (char *)malloc(sizeof(char)*w*h*3);\n  cout << \"font.cpp font reading in \" << (int)ch << \" with size of \" << (int)w << \",\" << (int)h << endl;\n  for (i=0;i<h;i++) {\n   for (j=0;j<w;j++) {\n    int index = (i*w+j)*3;\n    infile.read(&p[index],1);\n    infile.read(&p[index+1],1);\n    infile.read(&p[index+2],1);\n    /*int r = p[index];\n    if (r < 0) r += 255;\n    int g = p[index];\n    if (g < 0) g += 255;\n    int b = p[index];\n    if (b < 0) b += 255;\n    cout << r << \" \" << g << \" \" << b << endl;*/\n   }\n  }\n  letter = new Letter(w,h,p);\n  letters->insert(pair<char,Letter *>(ch,letter));\n }\n cout << \"font.cpp font finished loading of font \" << endl;\n}\n\nLetter::Letter(int w, int h, char *pix) {\n width = w;\n height = h;\n pixels = pix;\n}\n\nint Font::widthOf(char c) {\n if (letters->find(c) != letters->end()) {\n  return letters->find(c)->second->width;\n }\n return 0;\n}\n\n";
files.insert(pair<string,string*>("Font_cpp",&Font_cpp));
sprites_cpp = "#include \"sprites.h\"\n#include <cstdlib>\n\nmap<string,char *> spriteData;\nmap<string,int> spriteWidths;\nmap<string,int> spriteHeights;\n\nvoid initSprites() {\n spriteData = *(new map<string,char *>());\n spriteWidths = *(new map<string,int>());\n spriteHeights = *(new map<string,int>());\n/* -- SPRITE DATA -- */\n}\n\n";
files.insert(pair<string,string*>("sprites_cpp",&sprites_cpp));
Engine_cpp = "#include \"Engine.h\"\n#include <cstdlib>\n#include \"Rooms.h\"\n#include \"sprites.h\"\n\n//vector<ObjectType *> Engine::objectref;\nvector<Image *> Engine::imageref;\nvector<Object *> Engine::instanceref;\nvector<Room *> Engine::roomref;\nvector< Font *> Engine::fonts;\nint Engine::instanceid = 0;\nRoom *Engine::currentRoom;\nkeyhitmap *Engine::keys;\nkeyhitmap *Engine::keyslaststep;\nbool Engine::mouse_left_flagged;\nbool Engine::mouse_left_flagged_laststep;\nbool Engine::mouse_right_flagged;\nbool Engine::mouse_right_flagged_laststep;\nbool Engine::mouse_center_flagged;\nbool Engine::mouse_center_flagged_laststep;\nkeymap *Engine::keymaps;\nkeymap *Engine::keydownmaps;\nkeymap *Engine::keyupmaps;\nobjfunc Engine::beginStepEvent;\nobjfunc Engine::stepEvent;\nobjfunc Engine::endStepEvent;\ninstancemap *Engine::instances;\ncollidemap *Engine::collisionmap;\nfloat Engine::mousex;\nfloat Engine::mousey;\ndouble Engine::r;\ndouble Engine::g;\ndouble Engine::b;\nFont *Engine::currentFont;\narraymap *Engine::vecList;\nvector<fstream *> *Engine::filePtrRead;\nvector<fstream *> *Engine::filePtrWrite;\nmap<string,Variable *> *Engine::globalVars;\nvector<vector<Variable *> *> *Engine::vectors;\nVariable *Engine::keyboardString;\n\nvoid Engine::init() {\n\n Engine::keyboardString = new Variable(\"\");\n\n cout << \"engine.cpp init begin initialization\" << endl;\n Engine::currentRoom = NULL;\n\n Engine::globalVars = new map<string,Variable *>();\n\n cout << \"engine.cpp init creating reference vectors\" << endl;\n        Engine::instanceref = *(new vector<Object *>());\n        //Engine::objectref = *(new vector<ObjectType *>());\n        Engine::imageref = *(new vector<Image *>());\n        Engine::roomref = *(new vector<Room *>());\n Engine::fonts = *(new vector<Font *>());\n\n Engine::vecList = new vector<map<int, Variable *> *>();\n Engine::vectors = new vector<vector<Variable *> *>();\n\n Engine::filePtrRead = new vector<fstream *>();\n Engine::filePtrWrite = new vector<fstream *>();\n\n cout << \"engine.cpp init creating instance maps\" << endl;\n        Engine::instances = new instancemap();\n /* -- INSTANCE MAP -- */\n\n cout << \"engine.cpp init creating objects/rooms/images\" << endl;\n\n        fillImages();\n        fillObjects();\n        fillRooms();\n cout << \"engine.cpp completed creation of rooms \" << endl;\n fillFonts();\n\n        collisionmap = new collidemap();\n\n cout << \"engine.cpp init registering collisions\" << endl;\n\n        registerCollisions();\n\n        Engine::mouse_left_flagged = false;\n        Engine::mouse_left_flagged_laststep = false;\n        Engine::mouse_right_flagged = false;\n        Engine::mouse_right_flagged_laststep = false;\n        Engine::mouse_center_flagged = false;\n        Engine::mouse_center_flagged_laststep = false;\n\n cout << \"engine.cpp init creating keymaps\" << endl;\n\n        Engine::keys = new keyhitmap();\n        Engine::keyslaststep = new keyhitmap();\n        Engine::keymaps = new keymap();\n        Engine::keydownmaps = new keymap();\n        Engine::keyupmaps = new keymap();\n\n cout << \"engine.cpp init creating function maps \" << endl;\n\n        generateFunctionMaps();\n\n Engine::r = 0;\n Engine::g = 0;\n Engine::b = 0;\n\n cout << \"engine.cpp init initialization complete \" << endl;\n}\n\nvoid Engine::fillObjects() {\n /* -- CREATE OBJECT TYPES -- */\n}\n\nvoid Engine::fillImages() {\n initSprites();\n /* -- CREATE IMAGES -- */\n}\n\nvoid Engine::fillRooms() {\n /* -- CREATE ROOMS -- */\n\n cout << \"engine.cpp fillRooms there are \" << Engine::roomref.size() << \" rooms\" << endl;\n if (Engine::roomref.size() > 0) { \n         Engine::currentRoom = roomref[0];\n  cout << \"engine.cpp fillRooms current room creation code \" << endl;\n  Engine::currentRoom->initInstances();\n  Engine::currentRoom->create();\n  cout << \"engine.cpp fillRooms reshaping window to \" << Engine::currentRoom->width << \",\" << Engine::currentRoom->height << endl;\n  // forcing a reshape will cause main program to change to current room size\n  glutReshapeWindow(Engine::currentRoom->width,Engine::currentRoom->height);\n  cout << \"engine.cpp window reshaped \" << endl;\n }\n}\n\nvoid Engine::fillFonts() {\n /* -- CREATE FONTS -- */\n\n cout << \"engine.cpp fillFonts there are \" << Engine::fonts.size() << \" fonts\" << endl;\n if (Engine::fonts.size() > 0) {\n  Engine::currentFont = fonts[0];\n }\n}\n\nvoid Engine::registerCollisions() {\n /* -- REGISTER COLLISIONS -- */\n}\n\nvoid Engine::handleEvents() {\n        vector<Object *> instances = Engine::currentRoom->getInstances();\n        unsigned int i;\n        //int j;\n        keyhitmap::iterator itor = keys->begin();\n        while (itor != keys->end()) {\n                bool val = (*itor).second;\n                int id = (*itor).first;\n                if (val == true) {\n                        objfunc function = (*(keymaps->find(id))).second;\n                        if (function != NULL) {\n                                for (i=0;i<instances.size();i++) {\n                                        Object *inst = instances[i];\n     if (inst != NULL) {\n                                         (inst->*function)();\n     }\n                                }\n                        }\n   if (id >= 32 && id < 127) {\n    string str = Engine::keyboardString->getS();\n    str += (char)id;\n    *(Engine::keyboardString) = str;\n   }\n                }\n                itor ++;\n        }\n\n // left button\n if (mouse_left_flagged && !mouse_left_flagged_laststep) {\n  cout << \"engine.cpp handleEvents mouse left click at \" << Engine::mousex << \",\" << Engine::mousey << \" \" << instances.size() << endl;\n  for (i=0;i<instances.size();i++) {\n   Object *inst = instances[i];\n   if (inst != NULL) {\n    if (inst->pointInside(Engine::mousex,Engine::mousey)) {\n                   inst->mousepressed_left();\n    }\n    inst->globalmousepressed_left();\n   }\n                }\n }\n if (mouse_left_flagged) {\n  for (i=0;i<instances.size();i++) {\n                 Object *inst = instances[i];\n   if (inst != NULL) {\n   }\n                }\n }\n if (!mouse_left_flagged && mouse_left_flagged_laststep) {\n  for (i=0;i<instances.size();i++) {\n                 Object *inst = instances[i];\n   if (inst != NULL) {\n    inst->globalmousereleased_left();\n   }\n                }\n }\n\n // right button\n if (mouse_right_flagged && !mouse_right_flagged_laststep) {\n  for (i=0;i<instances.size();i++) {\n                 Object *inst = instances[i];\n   if (inst != NULL) {\n    if (inst->pointInside(Engine::mousex,Engine::mousey)) {\n                          inst->mousepressed_right();\n    }\n    inst->globalmousepressed_right();\n   }\n                }\n }\n if (mouse_right_flagged) {\n  for (i=0;i<instances.size();i++) {\n                 Object *inst = instances[i];\n   if (inst != NULL) {\n                         //inst->mouseclicked_right();\n   }\n                }\n }\n if (!mouse_right_flagged && mouse_right_flagged_laststep) {\n  for (i=0;i<instances.size();i++) {\n                 Object *inst = instances[i];\n   if (inst != NULL) {\n                         //inst->mousereleased_right();\n    inst->globalmousereleased_right();\n   }\n                }\n }\n\n // middle button\n if (mouse_center_flagged && !mouse_center_flagged_laststep) {\n  for (i=0;i<instances.size();i++) {\n                 Object *inst = instances[i];\n   if (inst != NULL) {\n    if (inst->pointInside(Engine::mousex,Engine::mousey)) {\n                          inst->mousepressed_middle();\n    }\n    inst->globalmousepressed_middle();\n   }\n                }\n }\n if (mouse_center_flagged) {\n  for (i=0;i<instances.size();i++) {\n                 Object *inst = instances[i];\n   if (inst != NULL) {\n                         //inst->mouseclicked_middle();\n   }\n                }\n }\n if (!mouse_center_flagged && mouse_center_flagged_laststep) {\n  for (i=0;i<instances.size();i++) {\n                 Object *inst = instances[i];\n   if (inst != NULL) {\n                         //inst->mousereleased_middle();\n    inst->globalmousereleased_middle();\n   }\n                }\n }\n\n        itor = keys->begin();\n        keyhitmap::iterator itor2 = keyslaststep->begin();\n        while (itor != keys->end()) {\n                (*itor2).second = (*itor).second;\n                (*itor).second = false;\n                itor ++;\n                itor2 ++;\n        }\n\n        mouse_left_flagged_laststep = mouse_left_flagged;\n        mouse_right_flagged_laststep = mouse_right_flagged;\n        mouse_center_flagged_laststep = mouse_center_flagged;\n}\n\nvoid Engine::beginStep() {\n        vector<Object *> instances = Engine::currentRoom->getInstances();\n        unsigned int i;\n        for (i=0;i<instances.size();i++) {\n                Object *inst = instances[i];\n  if (inst != NULL) {\n                 inst->step_begin();\n  }\n        }\n}\n\nvoid Engine::step() {\n        vector<Object *> instances = Engine::currentRoom->getInstances();\n        unsigned int i;\n        for (i=0;i<instances.size();i++) {\n                Object *inst = instances[i];\n  if (inst != NULL) {\n                 inst->step();\n  }\n        }\n}\n\nvoid Engine::endStep() {\n        vector<Object *> instances = Engine::currentRoom->getInstances();\n        unsigned int i;\n        for (i=0;i<instances.size();i++) {\n                Object *inst = instances[i];\n  if (inst != NULL) {\n                 inst->step_end();\n  }\n }\n \n updateObjects();\n}\n\nvoid Engine::checkCollisions() {\n        collidemap::iterator it;\n        unsigned int i,j;\n        for (it=collisionmap->begin();it!=collisionmap->end();it++) {\n                objlist *list = Engine::instances->find(it->first)->second;\n                objlist *list2 = Engine::instances->find(it->second)->second;\n                for (i=0;i<list->size();i++) {\n   for (j=0;j<list2->size();j++) {\n                         if (list->at(i)->check_collision_with_object(list2->at(j))) {\n                                 list->at(i)->collide_with(list2->at(i)->getId());\n                                 list2->at(j)->collide_with(list->at(i)->getId());\n                         }\n   }\n                }\n        }\n}\n\n/*ObjectType *Engine::getObject(unsigned int id) {\n        if (id >= objectref.size()) {\n                return NULL;\n        }\n        return objectref[id];\n}*/\n\nObject *Engine::getInstance(unsigned int id) {\n        if (id >= instanceref.size()) {\n                return NULL;\n        }\n        return instanceref[id];\n}\n\nImage *Engine::getSprite(unsigned int id) {\n        if (id >= imageref.size()) {\n                return NULL;\n        }\n        return imageref[id];\n}\n\nRoom *Engine::getRoom(unsigned int id) {\n        if (id >= roomref.size()) {\n                return NULL;\n        }\n        return roomref[id];\n}\n\nvoid Engine::setMouse(int x, int y) {\n Engine::mousex = x;\n Engine::mousey = y;\n}\n\nvoid Engine::setColors(double r, double g, double b) {\n Engine::r = r;\n Engine::g = g;\n Engine::b = b;\n}\n\nvoid Engine::updateObjects() {\n vector<Object *> instances = Engine::currentRoom->getInstances();\n        unsigned int i;\n        for (i=0;i<instances.size();i++) {\n                Object *inst = instances[i];\n  if (inst != NULL) {\n                 \n\n   // do various things to move objects, etc\n\n   inst->variables[\"x\"] = inst->x;\n   inst->variables[\"y\"] = inst->y;\n  }\n }\n}\n\n\n\n\n\n\n\n\n\n\nvoid Engine::generateFunctionMaps() {\n        //keys = new keyhitmap();\n        //keyslaststep = new keyhitmap();\n        //keymaps = new keymap();\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F1+200,&Object::key_F1));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_F1+200,&Object::keyup_F1));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F1+200,&Object::keydown_F1));\n        keys->insert(pair<int,bool>(GLUT_KEY_F1+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F1+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F2+200,&Object::key_F2));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_F2+200,&Object::keyup_F2));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F2+200,&Object::keydown_F2));\n        keys->insert(pair<int,bool>(GLUT_KEY_F2+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F2+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F3+200,&Object::key_F3));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_F3+200,&Object::keyup_F3));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F3+200,&Object::keydown_F3));\n        keys->insert(pair<int,bool>(GLUT_KEY_F3+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F3+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F4+200,&Object::key_F4));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_F4+200,&Object::keyup_F4));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F4+200,&Object::keydown_F4));\n        keys->insert(pair<int,bool>(GLUT_KEY_F4+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F4+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F5+200,&Object::key_F5));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_F5+200,&Object::keyup_F5));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F5+200,&Object::keydown_F5));\n        keys->insert(pair<int,bool>(GLUT_KEY_F5+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F5+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F6+200,&Object::key_F6));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_F6+200,&Object::keyup_F6));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F6+200,&Object::keydown_F6));\n        keys->insert(pair<int,bool>(GLUT_KEY_F6+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F6+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F7+200,&Object::key_F7));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_F7+200,&Object::keyup_F7));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F7+200,&Object::keydown_F7));\n        keys->insert(pair<int,bool>(GLUT_KEY_F7+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F7+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F8+200,&Object::key_F8));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_F8+200,&Object::keyup_F8));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F8+200,&Object::keydown_F8));\n        keys->insert(pair<int,bool>(GLUT_KEY_F8+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F8+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F9+200,&Object::key_F9));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_F9+200,&Object::keyup_F9));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F9+200,&Object::keydown_F9));\n        keys->insert(pair<int,bool>(GLUT_KEY_F9+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F9+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F10+200,&Object::key_F10));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_F10+200,&Object::keyup_F10));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F10+200,&Object::keydown_F10));\n        keys->insert(pair<int,bool>(GLUT_KEY_F10+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F10+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F11+200,&Object::key_F11));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_F11+200,&Object::keyup_F11));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F11+200,&Object::keydown_F11));\n        keys->insert(pair<int,bool>(GLUT_KEY_F11+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F11+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_F12+200,&Object::key_F12));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_F12+200,&Object::keyup_F12));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_F12+200,&Object::keydown_F12));\n        keys->insert(pair<int,bool>(GLUT_KEY_F12+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_F12+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_UP+200,&Object::key_up));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_UP+200,&Object::keyup_up));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_UP+200,&Object::keydown_up));\n        keys->insert(pair<int,bool>(GLUT_KEY_UP+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_UP+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_DOWN+200,&Object::key_down));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_DOWN+200,&Object::keyup_down));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_DOWN+200,&Object::keydown_down));\n        keys->insert(pair<int,bool>(GLUT_KEY_DOWN+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_DOWN+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_LEFT+200,&Object::key_left));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_LEFT+200,&Object::keyup_left));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_LEFT+200,&Object::keydown_left));\n        keys->insert(pair<int,bool>(GLUT_KEY_LEFT+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_LEFT+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_RIGHT+200,&Object::key_right));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_RIGHT+200,&Object::keyup_right));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_RIGHT+200,&Object::keydown_right));\n        keys->insert(pair<int,bool>(GLUT_KEY_RIGHT+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_RIGHT+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_PAGE_UP+200,&Object::key_page_up));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_PAGE_UP+200,&Object::keyup_page_up));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_PAGE_UP+200,&Object::keydown_page_up));\n        keys->insert(pair<int,bool>(GLUT_KEY_PAGE_UP+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_PAGE_UP+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_PAGE_DOWN+200,&Object::key_page_down));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_PAGE_DOWN+200,&Object::keyup_page_down));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_PAGE_DOWN+200,&Object::keydown_page_down));\n        keys->insert(pair<int,bool>(GLUT_KEY_PAGE_DOWN+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_PAGE_DOWN+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_HOME+200,&Object::key_home));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_HOME+200,&Object::keyup_home));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_HOME+200,&Object::keydown_home));\n        keys->insert(pair<int,bool>(GLUT_KEY_HOME+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_HOME+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_END+200,&Object::key_end));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_END+200,&Object::keyup_end));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_END+200,&Object::keydown_end));\n        keys->insert(pair<int,bool>(GLUT_KEY_END+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_END+200,false));\n        keymaps->insert(pair<int,objfunc>(GLUT_KEY_INSERT+200,&Object::key_insert));\n        keyupmaps->insert(pair<int,objfunc>(GLUT_KEY_INSERT+200,&Object::keyup_insert));\n        keydownmaps->insert(pair<int,objfunc>(GLUT_KEY_INSERT+200,&Object::keydown_insert));\n        keys->insert(pair<int,bool>(GLUT_KEY_INSERT+200,false));\n        keyslaststep->insert(pair<int,bool>(GLUT_KEY_INSERT+200,false));\n        keymaps->insert(pair<int,objfunc>('a',&Object::key_a));\n        keys->insert(pair<int,bool>('a',false));\n        keyslaststep->insert(pair<int,bool>('a',false));\n        keymaps->insert(pair<int,objfunc>('b',&Object::key_b));\n        keys->insert(pair<int,bool>('b',false));\n        keyslaststep->insert(pair<int,bool>('b',false));\n        keymaps->insert(pair<int,objfunc>('c',&Object::key_c));\n        keys->insert(pair<int,bool>('c',false));\n        keyslaststep->insert(pair<int,bool>('c',false));\n        keymaps->insert(pair<int,objfunc>('d',&Object::key_d));\n        keys->insert(pair<int,bool>('d',false));\n        keyslaststep->insert(pair<int,bool>('d',false));\n        keymaps->insert(pair<int,objfunc>('e',&Object::key_e));\n        keys->insert(pair<int,bool>('e',false));\n        keyslaststep->insert(pair<int,bool>('e',false));\n        keymaps->insert(pair<int,objfunc>('f',&Object::key_f));\n        keys->insert(pair<int,bool>('f',false));\n        keyslaststep->insert(pair<int,bool>('f',false));\n        keymaps->insert(pair<int,objfunc>('g',&Object::key_g));\n        keys->insert(pair<int,bool>('g',false));\n        keyslaststep->insert(pair<int,bool>('g',false));\n        keymaps->insert(pair<int,objfunc>('h',&Object::key_h));\n        keys->insert(pair<int,bool>('h',false));\n        keyslaststep->insert(pair<int,bool>('h',false));\n        keymaps->insert(pair<int,objfunc>('i',&Object::key_i));\n        keys->insert(pair<int,bool>('i',false));\n        keyslaststep->insert(pair<int,bool>('i',false));\n        keymaps->insert(pair<int,objfunc>('j',&Object::key_j));\n        keys->insert(pair<int,bool>('j',false));\n        keyslaststep->insert(pair<int,bool>('j',false));\n        keymaps->insert(pair<int,objfunc>('k',&Object::key_k));\n        keys->insert(pair<int,bool>('k',false));\n        keyslaststep->insert(pair<int,bool>('k',false));\n        keymaps->insert(pair<int,objfunc>('l',&Object::key_l));\n        keys->insert(pair<int,bool>('l',false));\n        keyslaststep->insert(pair<int,bool>('l',false));\n        keymaps->insert(pair<int,objfunc>('m',&Object::key_m));\n        keys->insert(pair<int,bool>('m',false));\n        keyslaststep->insert(pair<int,bool>('m',false));\n        keymaps->insert(pair<int,objfunc>('n',&Object::key_n));\n        keys->insert(pair<int,bool>('n',false));\n        keyslaststep->insert(pair<int,bool>('n',false));\n        keymaps->insert(pair<int,objfunc>('o',&Object::key_o));\n        keys->insert(pair<int,bool>('o',false));\n        keyslaststep->insert(pair<int,bool>('o',false));\n        keymaps->insert(pair<int,objfunc>('p',&Object::key_p));\n        keys->insert(pair<int,bool>('p',false));\n        keyslaststep->insert(pair<int,bool>('p',false));\n        keymaps->insert(pair<int,objfunc>('q',&Object::key_q));\n        keys->insert(pair<int,bool>('q',false));\n        keyslaststep->insert(pair<int,bool>('q',false));\n        keymaps->insert(pair<int,objfunc>('r',&Object::key_r));\n        keys->insert(pair<int,bool>('r',false));\n        keyslaststep->insert(pair<int,bool>('r',false));\n        keymaps->insert(pair<int,objfunc>('s',&Object::key_s));\n        keys->insert(pair<int,bool>('s',false));\n        keyslaststep->insert(pair<int,bool>('s',false));\n        keymaps->insert(pair<int,objfunc>('t',&Object::key_t));\n        keys->insert(pair<int,bool>('t',false));\n        keyslaststep->insert(pair<int,bool>('t',false));\n        keymaps->insert(pair<int,objfunc>('u',&Object::key_u));\n        keys->insert(pair<int,bool>('u',false));\n        keyslaststep->insert(pair<int,bool>('u',false));\n        keymaps->insert(pair<int,objfunc>('v',&Object::key_v));\n        keys->insert(pair<int,bool>('v',false));\n        keyslaststep->insert(pair<int,bool>('v',false));\n        keymaps->insert(pair<int,objfunc>('w',&Object::key_w));\n        keys->insert(pair<int,bool>('w',false));\n        keyslaststep->insert(pair<int,bool>('w',false));\n        keymaps->insert(pair<int,objfunc>('x',&Object::key_x));\n        keys->insert(pair<int,bool>('x',false));\n        keyslaststep->insert(pair<int,bool>('x',false));\n        keymaps->insert(pair<int,objfunc>('y',&Object::key_y));\n        keys->insert(pair<int,bool>('y',false));\n        keyslaststep->insert(pair<int,bool>('y',false));\n        keymaps->insert(pair<int,objfunc>('z',&Object::key_z));\n        keys->insert(pair<int,bool>('z',false));\n        keyslaststep->insert(pair<int,bool>('z',false));\n        keys->insert(pair<int,bool>(' ',false));\n        keyslaststep->insert(pair<int,bool>(' ',false));\n        keys->insert(pair<int,bool>('1',false));\n        keyslaststep->insert(pair<int,bool>('1',false));\n        keys->insert(pair<int,bool>('2',false));\n        keyslaststep->insert(pair<int,bool>('2',false));\n        keys->insert(pair<int,bool>('3',false));\n        keyslaststep->insert(pair<int,bool>('3',false));\n        keys->insert(pair<int,bool>('4',false));\n        keyslaststep->insert(pair<int,bool>('4',false));\n        keys->insert(pair<int,bool>('5',false));\n        keyslaststep->insert(pair<int,bool>('5',false));\n\n        beginStepEvent = &Object::step_begin;\n        stepEvent = &Object::step;\n        endStepEvent = &Object::step_end;\n}\n\n";
files.insert(pair<string,string*>("Engine_cpp",&Engine_cpp));
sprites_h = "#ifndef SPRITESH\n#define SPRITESH\n#include <map>\n#include <string>\nusing namespace std;\n\nextern map<string,char *> spriteData;\nextern map<string,int> spriteWidths;\nextern map<string,int> spriteHeights;\n\nvoid initSprites();\n\n#endif\n\n";
files.insert(pair<string,string*>("sprites_h",&sprites_h));
Objects_h = "#ifndef OBJECTSH\n#define OBJECTSH\n\n#include \"Object.h\"\n/* -- OBJECT INCLUDES -- */\n\n#endif\n\n";
files.insert(pair<string,string*>("Objects_h",&Objects_h));
Room_cpp = "#include \"Room.h\"\n#include <iostream>\n\nusing namespace std;\n\nRoom::Room(int i, string t, int w, int h, int sp) {\n        id = i;\n        title = t;\n        width = w;\n        height = h;\n        speed = sp;\n        instances = *(new vector<Object *>());\n}\n\nvoid Room::initInstances() {\n\n}\n\nvoid Room::create() {\n\n}\n\nvoid Room::draw() {\n        unsigned int i;\n        for (i=0;i<instances.size();i++) {\n  if (instances[i] != NULL) {\n                 instances[i]->draw();\n  }\n        }\n}\n\n";
files.insert(pair<string,string*>("Room_cpp",&Room_cpp));
Image_h = "/* Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above notice and this permission notice shall be included in all copies\n * or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/* File for \"Putting It All Together\" lesson of the OpenGL tutorial on\n * www.videotutorialsrock.com\n */\n\n\n\n#ifndef IMAGE_LOADER_H_INCLUDED\n#define IMAGE_LOADER_H_INCLUDED\n\n#ifdef __APPLE__\n#include <OpenGL/OpenGL.h>\n#include <GLUT/glut.h>\n#else\n#include <GL/glut.h>\n#endif\n\n#define IMAGE_FILE 1\n#define IMAGE_DATA 2\n\n//Represents an image\nclass Image {\n public:\n  void loadBMP(char* filename);\n  Image(char* ps);\n  Image(char* ps,float, float);\n  ~Image();\n  \n  /* An array of the form (R1, G1, B1, R2, G2, B2, ...) indicating the\n   * color of each pixel in image.  Color components range from 0 to 255.\n   * The array starts the bottom-left pixel, then moves right to the end\n   * of the row, then moves up to the next column, and so on.  This is the\n   * format in which OpenGL likes images.\n   */\n  char* pixels;\n  float width;\n  float height;\n  float dheight;\n  float dwidth;\n                int *blocked;\n\n  GLuint _textureId;\n  void draw(float,float);\n  GLuint loadTexture(char *);\n        private:\n                void computeBlocked();\n};\n\n\n\n\n\n\n\n\n\n\n#endif\n\n";
files.insert(pair<string,string*>("Image_h",&Image_h));
Makefile = "CC = g++\nCFLAGS = -Wall -g\nPROG = game\nCORE_FILES = Engine.cpp Engine.h Image.cpp Image.h Object.cpp Object.h Objects.h Room.cpp Room.h Rooms.h common.cpp common.h main.cpp Variable.h Variable.cpp Font.h Font.cpp sprites.h sprites.cpp\nEXTRA_FILES = \n\n\nifeq ($(shell uname),Darwin)\n	LIBS = -framework OpenGL -framework GLUT\nelse\n	LIBS = -lglut\nendif\n\nall:\n	$(CC) $(LIBS) $(CFLAGS) -o $(PROG) $(CORE_FILES) $(EXTRA_FILES)\n\nclean:\n	rm -f *.o *.gch\n\ncleancode:\n	rm -f $(CORE_FILES) $(EXTRA_FILES) *.o *.gch\n\ncleanall:\n	rm -f $(CORE_FILES) $(EXTRA_FILES) $(PROG) Makefile *.o *.gch\n\n\n";
files.insert(pair<string,string*>("Makefile",&Makefile));
Rooms_h = "#ifndef ROOMSH\n#define ROOMSH\n\n#include \"Room.h\"\n/* -- ROOM INCLUDES -- */\n\n#endif\n\n";
files.insert(pair<string,string*>("Rooms_h",&Rooms_h));
Engine_h = "#ifndef ENGINE\n#define ENGINE\n\n#include \"Objects.h\"\n#include <vector>\n#include \"Image.h\"\n#include \"Room.h\"\n#include <map>\n#include \"Font.h\"\n\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\n#ifdef __APPLE__\n#include <OpenGL/OpenGL.h>\n#include <GLUT/glut.h>\n#else\n#include <GL/glut.h>\n#endif\n\nusing namespace std;\n\ntypedef void (Object::*objfunc)();\n\ntypedef map<int,objfunc> keymap;\n\ntypedef map<int,bool> keyhitmap;\n\ntypedef vector<Object *> objlist;\n\ntypedef map<int,objlist *> instancemap;\n\ntypedef map<int,int> collidemap;\n\ntypedef vector<map<int, Variable *> *> arraymap;\n\nclass Engine {\npublic:\n        static void init();\n        static void fillObjects();\n        static void fillImages();\n        static void fillRooms();\n static void fillFonts();\n        static void registerCollisions();\n\n        static void generateFunctionMaps();\n\n        static void handleEvents();\n        static void beginStep();\n        static void step();\n        static void endStep();\n        static void checkCollisions();\n\n        //static vector<ObjectType *> objectref;\n        static vector<Image *> imageref;\n        static vector<Object *> instanceref;\n        static vector<Room *> roomref;\n\n        //static bool keys[500];\n        static keyhitmap *keys;\n        //static bool keyslaststep[500];\n        static keyhitmap *keyslaststep;\n        static objfunc beginStepEvent;\n        static objfunc stepEvent;\n        static objfunc endStepEvent;\n\n        static int instanceid;\n        //static ObjectType *getObject(unsigned int id);\n        static Object *getInstance(unsigned int id);\n        static Image *getSprite(unsigned int id);\n        static Room *getRoom(unsigned int id);\n        static Room *currentRoom;\n\n        static bool mouse_left_flagged;\n        static bool mouse_left_flagged_laststep;\n        static bool mouse_right_flagged;\n        static bool mouse_right_flagged_laststep;\n        static bool mouse_center_flagged;\n        static bool mouse_center_flagged_laststep;\n\n static float mousex;\n static float mousey;\n\n static void setMouse(int x, int y);\n        \n        static keymap *keymaps;\n static keymap *keydownmaps;\n        static keymap *keyupmaps;\n\n static double r;\n static double g;\n static double b;\n\n static Font *currentFont;\n\n static void setColors(double,double,double);\n\n        static instancemap *instances;\n\n        static collidemap *collisionmap;\n\n static void updateObjects();\n\n static vector<Font *> fonts;\n\n static arraymap *vecList;\n\n static vector<fstream *> *filePtrRead;\n static vector<fstream *> *filePtrWrite;\n\n static map<string,Variable *> *globalVars;\n\n static vector<vector<Variable *> *> *vectors;\n\n static Variable *keyboardString;\n};\n\n#endif\n\n";
files.insert(pair<string,string*>("Engine_h",&Engine_h));
Image_cpp = "/* Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above notice and this permission notice shall be included in all copies\n * or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/* File for \"Putting It All Together\" lesson of the OpenGL tutorial on\n * www.videotutorialsrock.com\n */\n\n\n\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <cstdlib>\n\n#include \"Image.h\"\n\n#ifdef __APPLE__\n#include <OpenGL/OpenGL.h>\n#include <GLUT/glut.h>\n#else\n#include <GL/glut.h>\n#endif\n\nusing namespace std;\n\nGLuint Image::loadTexture(char *pixels) {\n GLuint textureId;\n glGenTextures(1, &textureId);\n glBindTexture(GL_TEXTURE_2D, textureId);\n glTexImage2D(GL_TEXTURE_2D,\n     0,\n     GL_RGB,\n     width, height,\n     0,\n     GL_RGB,\n     GL_UNSIGNED_BYTE,\n     pixels);\n return textureId;\n}\n\nImage::Image(char* filename, float w, float h) {\n pixels = filename;\n width = w;\n height = h;\n _textureId = loadTexture(pixels);\n        computeBlocked();\n}\n\nImage::Image(char* filename) {\n loadBMP(filename);\n _textureId = loadTexture(pixels);\n        computeBlocked();\n}\n\nImage::~Image() {\n delete[] pixels;\n}\n\nvoid Image::draw(float x, float y) {\n //if (!(width != dwidth || height != dheight)) {\n //if ((int)dwidth % 2 != 0 || (int)dheight % 2 != 0) {\n  glTranslatef(x, y, 0.0f);\n  glEnable(GL_TEXTURE_2D);\n  glBindTexture(GL_TEXTURE_2D, _textureId);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n  glColor3f(1.0f, 1.0f, 1.0f);\n  glBegin(GL_QUADS);\n  glNormal3f(0.0, 0.0f, 1.0f);\n  glTexCoord2f(0.0f, 0.0f);\n  glVertex2f(0,0);\n  glTexCoord2f(1.0f, 0.0f);\n  glVertex2f(width, 0);\n  glTexCoord2f(1.0f, -1.0f);\n  glVertex2f(width, height);\n  glTexCoord2f(0.0f, -1.0f);\n  glVertex2f(0, height);\n  glEnd();\n  glDisable(GL_TEXTURE_2D);\n  glTranslatef(-x,-y,0.0f);\n //} else {\n // glRasterPos2f(x+1,y+16);\n // glDrawPixels(width,height,GL_RGB,GL_UNSIGNED_BYTE,pixels);\n //}\n}\n\nnamespace {\n //Converts a four-character array to an integer, using little-endian form\n int toInt(const char* bytes) {\n  return (int)(((unsigned char)bytes[3] << 24) |\n      ((unsigned char)bytes[2] << 16) |\n      ((unsigned char)bytes[1] << 8) |\n      (unsigned char)bytes[0]);\n }\n \n //Converts a two-character array to a short, using little-endian form\n short toShort(const char* bytes) {\n  return (short)(((unsigned char)bytes[1] << 8) |\n        (unsigned char)bytes[0]);\n }\n \n //Reads the next four bytes as an integer, using little-endian form\n int readInt(ifstream &input) {\n  char buffer[4];\n  input.read(buffer, 4);\n  return toInt(buffer);\n }\n \n //Reads the next two bytes as a short, using little-endian form\n short readShort(ifstream &input) {\n  char buffer[2];\n  input.read(buffer, 2);\n  return toShort(buffer);\n }\n \n //Just like auto_ptr, but for arrays\n template<class T>\n class auto_array {\n  private:\n   T* array;\n   mutable bool isReleased;\n  public:\n   explicit auto_array(T* array_ = NULL) :\n    array(array_), isReleased(false) {\n   }\n   \n   auto_array(const auto_array<T> &aarray) {\n    array = aarray.array;\n    isReleased = aarray.isReleased;\n    aarray.isReleased = true;\n   }\n   \n   ~auto_array() {\n    if (!isReleased && array != NULL) {\n     delete[] array;\n    }\n   }\n   \n   T* get() const {\n    return array;\n   }\n   \n   T &operator*() const {\n    return *array;\n   }\n   \n   void operator=(const auto_array<T> &aarray) {\n    if (!isReleased && array != NULL) {\n     delete[] array;\n    }\n    array = aarray.array;\n    isReleased = aarray.isReleased;\n    aarray.isReleased = true;\n   }\n   \n   T* operator->() const {\n    return array;\n   }\n   \n   T* release() {\n    isReleased = true;\n    return array;\n   }\n   \n   void reset(T* array_ = NULL) {\n    if (!isReleased && array != NULL) {\n     delete[] array;\n    }\n    array = array_;\n   }\n   \n   T* operator+(int i) {\n    return array + i;\n   }\n   \n   T &operator[](int i) {\n    return array[i];\n   }\n };\n}\n\nvoid Image::loadBMP(char* filename) {\n ifstream input;\n input.open(filename, ifstream::binary);\n assert(!input.fail() || !\"Could not find file\");\n char buffer[2];\n input.read(buffer, 2);\n assert((buffer[0] == 'B' && buffer[1] == 'M') || !\"Not a bitmap file\");\n input.ignore(8);\n int dataOffset = readInt(input);\n \n //Read the header\n int headerSize = readInt(input);\n int width;\n int height;\n switch(headerSize) {\n  case 40:\n   //V3\n   width = readInt(input);\n   height = readInt(input);\n   input.ignore(2);\n   assert(readShort(input) == 24 || !\"Image is not 24 bits per pixel\");\n   assert(readShort(input) == 0 || !\"Image is compressed\");\n   break;\n  case 12:\n   //OS/2 V1\n   width = readShort(input);\n   height = readShort(input);\n   input.ignore(2);\n   assert(readShort(input) == 24 || !\"Image is not 24 bits per pixel\");\n   break;\n  case 64:\n   //OS/2 V2\n   assert(!\"Can't load OS/2 V2 bitmaps\");\n   break;\n  case 108:\n   //Windows V4\n   assert(!\"Can't load Windows V4 bitmaps\");\n   break;\n  case 124:\n   //Windows V5\n   assert(!\"Can't load Windows V5 bitmaps\");\n   break;\n  default:\n   assert(!\"Unknown bitmap format\");\n }\n \n //Read the data\n int bytesPerRow = ((width * 3 + 3) / 4) * 4 - (width * 3 % 4);\n int size = bytesPerRow * height;\n auto_array<char> pixels(new char[size]);\n input.seekg(dataOffset, ios_base::beg);\n input.read(pixels.get(), size);\n \n //Get the data into the right format\n char *pixels2 = (char *)malloc(sizeof(char)*width * height * 3);\n for(int y = 0; y < height; y++) {\n  for(int x = 0; x < width; x++) {\n   for(int c = 0; c < 3; c++) {\n    pixels2[3 * (width * y + x) + c] =\n     pixels[bytesPerRow * y + 3 * x + (2 - c)];\n   }\n  }\n }\n \n input.close();\n //return new Image(pixels2.release(), width, height);\n this->width = width;\n this->height = height;\n //return pixels2.release();\n this->pixels = pixels2;\n}\n\nvoid Image::computeBlocked() {\n        blocked = (int *)malloc(sizeof(int)*width*height);\n        float r,g,b,rt,gt,bt;\n        int i,j;\n        r = pixels[((int)height-1)*(int)width*3];\n        g = pixels[((int)height-1)*(int)width*3+1];\n        b = pixels[((int)height-1)*(int)width*3+2];\n        for (i=0;i<height;i++) {\n                for (j=0;j<width;j++) {\n                        rt = pixels[i*(int)width+j*3];\n                        gt = pixels[i*(int)width+j*3+1];\n                        bt = pixels[i*(int)width+j*3+2];\n                        if (rt == r && gt == g && bt == b) {\n                                blocked[i*(int)width+j] = 1;\n                        } else {\n                                blocked[i*(int)width+j] = 0;\n                        }\n                }\n        }\n}\n\n\n\n\n\n\n\n\n\n\n";
files.insert(pair<string,string*>("Image_cpp",&Image_cpp));
Variable_h = "#ifndef VARIABLEH\n#define VARIABLEH\n\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Engine;\n\nclass Variable {\n friend ostream& operator<<(ostream &, const Variable &);\npublic:\n Variable();\n Variable(int);\n Variable(string);\n Variable &operator=(int);\n Variable &operator=(string);\n Variable &operator=(const Variable &);\n Variable &operator=(const Variable *);\n\n Variable &operator++();\n Variable &operator++(int);\n\n Variable operator+(const Variable &);\n Variable operator+(const int);\n Variable operator+(const string);\n\n Variable operator/(const Variable &);\n Variable operator/(const int);\n\n void operator+=(const Variable &);\n void operator+=(const int);\n void operator+=(const string);\n\n //void operator/=(const Variable &);\n //void operator/=(const int);\n\n Variable &operator[](int);\n\n friend bool operator<(const Variable &, int);\n friend bool operator<(const Variable &, const Variable &);\n\n //friend bool operator>=(const Variable &, int);\n //friend bool operator>=(const Variable &, const Variable &);\n\n //friend bool operator<=(const Variable &, int);\n //friend bool operator<=(const Variable &, const Variable &);\n\n operator float() {return (float)idata;}\n operator string() {return sdata;}\n //operator int() {return idata;}\n\n friend bool operator==(const Variable &, string);\n friend bool operator==(const Variable &, int);\n friend bool operator==(const Variable &, const Variable &);\n\n friend bool operator!=(const Variable &, string);\n friend bool operator!=(const Variable &, int);\n friend bool operator!=(const Variable &, const Variable &);\n\n string getS();\n int getI();\nprivate:\n int type; // 1=int, 2=string\n string sdata;\n int idata;\n bool isArray;\n};\n\n#endif\n\n";
files.insert(pair<string,string*>("Variable_h",&Variable_h));
Object_cpp = "#include \"Object.h\"\n#include <string>\n#include \"common.h\"\n\n#ifdef __APPLE__\n#include <OpenGL/OpenGL.h>\n#include <GLUT/glut.h>\n#else\n#include <GL/glut.h>\n#endif\n\nusing namespace std;\n\nObject::Object(int i, float xx, float yy) {\n id = i;\n        x = xx;\n        y = yy;\n variables = *(new Variables());\n variables[\"id\"] = id;\n        create();\n}\n\nvoid Object::create() {}\n\nvoid Object::destroy() {}\n\nvoid Object::draw() {\n if (sprite != noone) {\n                draw_sprite(sprite,0,x,y);\n }\n}\n\nvoid Object::key_up() {}\nvoid Object::key_down() {}\nvoid Object::key_left() {}\nvoid Object::key_right() {}\nvoid Object::key_F1() {}\nvoid Object::key_F2() {}\nvoid Object::key_F3() {}\nvoid Object::key_F4() {}\nvoid Object::key_F5() {}\nvoid Object::key_F6() {}\nvoid Object::key_F7() {}\nvoid Object::key_F8() {}\nvoid Object::key_F9() {}\nvoid Object::key_F10() {}\nvoid Object::key_F11() {}\nvoid Object::key_F12() {}\nvoid Object::key_page_down() {}\nvoid Object::key_page_up() {}\nvoid Object::key_home() {}\nvoid Object::key_end() {}\nvoid Object::key_insert() {}\nvoid Object::key_a() {}\nvoid Object::key_b() {}\nvoid Object::key_c() {}\nvoid Object::key_d() {}\nvoid Object::key_e() {}\nvoid Object::key_f() {}\nvoid Object::key_g() {}\nvoid Object::key_h() {}\nvoid Object::key_i() {}\nvoid Object::key_j() {}\nvoid Object::key_k() {}\nvoid Object::key_l() {}\nvoid Object::key_m() {}\nvoid Object::key_n() {}\nvoid Object::key_o() {}\nvoid Object::key_p() {}\nvoid Object::key_q() {}\nvoid Object::key_r() {}\nvoid Object::key_s() {}\nvoid Object::key_t() {}\nvoid Object::key_u() {}\nvoid Object::key_v() {}\nvoid Object::key_w() {}\nvoid Object::key_x() {}\nvoid Object::key_y() {}\nvoid Object::key_z() {}\nvoid Object::key_any() {}\n\nvoid Object::keyup_up() {}\nvoid Object::keyup_down() {}\nvoid Object::keyup_left() {}\nvoid Object::keyup_right() {}\nvoid Object::keyup_F1() {}\nvoid Object::keyup_F2() {}\nvoid Object::keyup_F3() {}\nvoid Object::keyup_F4() {}\nvoid Object::keyup_F5() {}\nvoid Object::keyup_F6() {}\nvoid Object::keyup_F7() {}\nvoid Object::keyup_F8() {}\nvoid Object::keyup_F9() {}\nvoid Object::keyup_F10() {}\nvoid Object::keyup_F11() {}\nvoid Object::keyup_F12() {}\nvoid Object::keyup_page_down() {}\nvoid Object::keyup_page_up() {}\nvoid Object::keyup_home() {}\nvoid Object::keyup_end() {}\nvoid Object::keyup_insert() {}\nvoid Object::keyup_a() {}\nvoid Object::keyup_b() {}\nvoid Object::keyup_c() {}\nvoid Object::keyup_d() {}\nvoid Object::keyup_e() {}\nvoid Object::keyup_f() {}\nvoid Object::keyup_g() {}\nvoid Object::keyup_h() {}\nvoid Object::keyup_i() {}\nvoid Object::keyup_j() {}\nvoid Object::keyup_k() {}\nvoid Object::keyup_l() {}\nvoid Object::keyup_m() {}\nvoid Object::keyup_n() {}\nvoid Object::keyup_o() {}\nvoid Object::keyup_p() {}\nvoid Object::keyup_q() {}\nvoid Object::keyup_r() {}\nvoid Object::keyup_s() {}\nvoid Object::keyup_t() {}\nvoid Object::keyup_u() {}\nvoid Object::keyup_v() {}\nvoid Object::keyup_w() {}\nvoid Object::keyup_x() {}\nvoid Object::keyup_y() {}\nvoid Object::keyup_z() {}\nvoid Object::keyup_any() {}\n\nvoid Object::keydown_up() {}\nvoid Object::keydown_down() {}\nvoid Object::keydown_left() {}\nvoid Object::keydown_right() {}\nvoid Object::keydown_F1() {}\nvoid Object::keydown_F2() {}\nvoid Object::keydown_F3() {}\nvoid Object::keydown_F4() {}\nvoid Object::keydown_F5() {}\nvoid Object::keydown_F6() {}\nvoid Object::keydown_F7() {}\nvoid Object::keydown_F8() {}\nvoid Object::keydown_F9() {}\nvoid Object::keydown_F10() {}\nvoid Object::keydown_F11() {}\nvoid Object::keydown_F12() {}\nvoid Object::keydown_page_down() {}\nvoid Object::keydown_page_up() {}\nvoid Object::keydown_home() {}\nvoid Object::keydown_end() {}\nvoid Object::keydown_insert() {}\n\nvoid Object::mousepressed_left() {}\nvoid Object::mousepressed_right() {}\nvoid Object::mousepressed_middle() {}\n\nvoid Object::globalmousepressed_left() {}\nvoid Object::globalmousepressed_right() {}\nvoid Object::globalmousepressed_middle() {}\n\nvoid Object::globalmousereleased_left() {}\nvoid Object::globalmousereleased_right() {}\nvoid Object::globalmousereleased_middle() {}\n\nvoid Object::step_begin() {}\nvoid Object::step() {}\nvoid Object::step_end() {}\n\nstring Object::getName() {\n        return name;\n}\n\nbool Object::check_collision_with_object(Object *object) {\n        return false;\n}\n\nvoid Object::collide_with(int objectId) {\n        \n}\n\nbool Object::pointInside(float px, float py) {\n if (Engine::getSprite(sprite) == NULL) {\n  return false;\n }\n float width = Engine::getSprite(sprite)->width;\n float height = Engine::getSprite(sprite)->height;\n\n cout << \"object.cpp pointInside \" << px << \" \" << x << \" \" << py << \" \" << y << endl;\n\n return (px >= x && px <= x+width && py >= y && py <= y+height);\n}\n\n/* variables class stuff */\n\nVariables::Variables() {\n vars = *(new map<string,Variable>());\n}\n\nVariable &Variables::operator[](string key) {\n vector<string> toks;\n Tokenize(key,toks,\".\");\n\n /* keyword variables */\n if (key == \"keyboard_string\") {\n  return *Engine::keyboardString;\n }\n\n if (toks.size() > 1) {\n  /*cout << \"object.cpp variables[] found reference request \" << endl;*/\n  if (toks[0] == \"global\") {\n   if (Engine::globalVars->find(toks[1]) == Engine::globalVars->end()) {\n    Engine::globalVars->insert(pair<string,Variable *>(toks[1],new Variable(0)));\n   }\n   return *(Engine::globalVars->find(toks[1])->second);\n  }\n  if (vars.find(toks[0]) == vars.end()) {\n   return *(new Variable(0));\n  }\n  int instanceId = vars[toks[0]];\n  /*cout << \"object.cpp variables[] \" << key << \" translates to \" << instanceId << endl;*/\n  unsigned int i;\n  for (i=0;i<Engine::instanceref.size();i++) {\n   if (Engine::instanceref[i]->id == instanceId) {\n    return Engine::instanceref[i]->variables[toks[1]];\n   }\n  }\n  return *(new Variable(0));\n } else {\n  if (vars.find(key) == vars.end()) {\n   vars[key] = *(new Variable());\n  }\n  return vars[key];\n }\n}\n\n";
files.insert(pair<string,string*>("Object_cpp",&Object_cpp));
Object_h = "#ifndef OBJECTH\n#define OBJECTH\n\n#include <string>\n#include <map>\n#include \"Image.h\"\n#include \"Variable.h\"\n\nusing namespace std;\n\nclass Variables {\npublic:\n Variables();\n map<string,Variable> vars;\n Variable &operator[](string key);\n};\n\nclass Object {\npublic:\n Object(int i, float x, float y);\n virtual void create();\n virtual void destroy();\n virtual void draw();\n\n        virtual void key_up();\n        virtual void key_down();\n        virtual void key_left();\n        virtual void key_right();\n        virtual void key_F1();\n        virtual void key_F2();\n        virtual void key_F3();\n        virtual void key_F4();\n        virtual void key_F5();\n        virtual void key_F6();\n        virtual void key_F7();\n        virtual void key_F8();\n        virtual void key_F9();\n        virtual void key_F10();\n        virtual void key_F11();\n        virtual void key_F12();\n        virtual void key_page_down();\n        virtual void key_page_up();\n        virtual void key_home();\n        virtual void key_end();\n        virtual void key_insert();\n virtual void key_a();\n virtual void key_b();\n virtual void key_c();\n virtual void key_d();\n virtual void key_e();\n virtual void key_f();\n virtual void key_g();\n virtual void key_h();\n virtual void key_i();\n virtual void key_j();\n virtual void key_k();\n virtual void key_l();\n virtual void key_m();\n virtual void key_n();\n virtual void key_o();\n virtual void key_p();\n virtual void key_q();\n virtual void key_r();\n virtual void key_s();\n virtual void key_t();\n virtual void key_u();\n virtual void key_v();\n virtual void key_w();\n virtual void key_x();\n virtual void key_y();\n virtual void key_z();\n virtual void key_any();\n\n virtual void keyup_up();\n        virtual void keyup_down();\n        virtual void keyup_left();\n        virtual void keyup_right();\n        virtual void keyup_F1();\n        virtual void keyup_F2();\n        virtual void keyup_F3();\n        virtual void keyup_F4();\n        virtual void keyup_F5();\n        virtual void keyup_F6();\n        virtual void keyup_F7();\n        virtual void keyup_F8();\n        virtual void keyup_F9();\n        virtual void keyup_F10();\n        virtual void keyup_F11();\n        virtual void keyup_F12();\n        virtual void keyup_page_down();\n        virtual void keyup_page_up();\n        virtual void keyup_home();\n        virtual void keyup_end();\n        virtual void keyup_insert();\n virtual void keyup_a();\n virtual void keyup_b();\n virtual void keyup_c();\n virtual void keyup_d();\n virtual void keyup_e();\n virtual void keyup_f();\n virtual void keyup_g();\n virtual void keyup_h();\n virtual void keyup_i();\n virtual void keyup_j();\n virtual void keyup_k();\n virtual void keyup_l();\n virtual void keyup_m();\n virtual void keyup_n();\n virtual void keyup_o();\n virtual void keyup_p();\n virtual void keyup_q();\n virtual void keyup_r();\n virtual void keyup_s();\n virtual void keyup_t();\n virtual void keyup_u();\n virtual void keyup_v();\n virtual void keyup_w();\n virtual void keyup_x();\n virtual void keyup_y();\n virtual void keyup_z();\n virtual void keyup_any();\n\n        virtual void keydown_up();\n        virtual void keydown_down();\n        virtual void keydown_left();\n        virtual void keydown_right();\n        virtual void keydown_F1();\n        virtual void keydown_F2();\n        virtual void keydown_F3();\n        virtual void keydown_F4();\n        virtual void keydown_F5();\n        virtual void keydown_F6();\n        virtual void keydown_F7();\n        virtual void keydown_F8();\n        virtual void keydown_F9();\n        virtual void keydown_F10();\n        virtual void keydown_F11();\n        virtual void keydown_F12();\n        virtual void keydown_page_down();\n        virtual void keydown_page_up();\n        virtual void keydown_home();\n        virtual void keydown_end();\n        virtual void keydown_insert();\n\n virtual void mousepressed_left();\n virtual void mousepressed_right();\n virtual void mousepressed_middle();\n\n virtual void globalmousepressed_left();\n virtual void globalmousepressed_right();\n virtual void globalmousepressed_middle();\n\n virtual void globalmousereleased_left();\n virtual void globalmousereleased_right();\n virtual void globalmousereleased_middle();\n\n        virtual void step_begin();\n        virtual void step();\n        virtual void step_end();\n\n string getName();\n int getId() {return id;}\n int getSprite() {return sprite;}\n\n        bool check_collision_with_object(Object *object);\n        virtual void collide_with(int objectId);\n\n int id;\n int sprite;\n        float x;\n        float y;\n int objectId;\n\n string name;\n\n Variables variables;\n\n bool pointInside(float x, float y);\n};\n\n#endif\n\n";
files.insert(pair<string,string*>("Object_h",&Object_h));
Variable_cpp = "#include \"Variable.h\"\n#include \"Engine.h\"\n\nVariable::Variable() {\n sdata = \"\";\n idata = 0;\n /* default to int */\n type = 1;\n isArray = false;\n}\n\nVariable::Variable(int d) {\n sdata = \"\";\n idata = d;\n type = 1;\n isArray = false;\n}\n\nVariable::Variable(string d) {\n sdata = d;\n idata = 0;\n type = 2;\n isArray = false;\n}\n\nVariable &Variable::operator=(int data) {\n type = 1;\n idata = data;\n isArray = false;\n return *this;\n}\n\nVariable &Variable::operator=(string data) {\n type = 2;\n sdata = data;\n isArray = false;\n return *this;\n}\n\nVariable &Variable::operator=(const Variable &other) {\n type = other.type;\n idata = other.idata;\n sdata = other.sdata;\n isArray = other.isArray;\n return *this;\n}\n\nVariable &Variable::operator=(const Variable *other) {\n type = other->type;\n idata = other->idata;\n sdata = other->sdata;\n isArray = other->isArray;\n return *this;\n}\n\nVariable &Variable::operator++() {\n if (type == 1) {\n  idata ++;\n }\n isArray = false;\n return *this;\n}\n\nVariable &Variable::operator++(int unused) {\n if (type == 1) {\n  idata ++;\n }\n isArray = false;\n return *this;\n}\n\nVariable Variable::operator+(const Variable &var2) {\n Variable ret = *(new Variable());\n if (type == var2.type) {\n  ret.type = type;\n }\n ret.idata = idata+var2.idata;\n ret.sdata = sdata+var2.sdata;\n ret.isArray = false;\n return ret;\n}\n\nVariable Variable::operator+(const int data) {\n Variable ret = *(new Variable());\n if (type == 1) {\n  ret.type = 1;\n  ret.idata = idata+data;\n }\n ret.isArray = false;\n return ret;\n}\n\nVariable Variable::operator+(const string data) {\n Variable ret = *(new Variable());\n if (type == 2) {\n  ret.type = 2;\n  ret.sdata = sdata+data;\n }\n ret.isArray = false;\n return ret;\n}\n\nVariable Variable::operator/(const Variable &data) {\n Variable ret = *(new Variable());\n if (type == 1 and data.type == 1) {\n  ret.type = 1;\n  ret.idata = idata/data.idata;\n }\n ret.isArray = false;\n return ret;\n}\n\nVariable Variable::operator/(const int data) {\n Variable ret = *(new Variable());\n if (type == 1) {\n  ret.type = 1;\n  ret.idata = idata/data;\n }\n ret.isArray = false;\n return ret;\n}\n\nvoid Variable::operator+=(const Variable &var2) {\n if (type == var2.type) {\n  if (type == 1) {\n   idata = idata+var2.idata;\n  } else if (type == 2) {\n   sdata = sdata+var2.sdata;\n  }\n }\n isArray = false;\n}\n\nvoid Variable::operator+=(const int data) {\n if (type == 1) {\n  idata = idata+data;\n }\n isArray = false;\n}\n\nvoid Variable::operator+=(const string data) {\n if (type == 2) {\n  sdata = sdata+data;\n }\n isArray = false;\n}\n\n/*void operator/=(const Variable &data) {\n if (type == 1 && data.type == 1) {\n  idata /= data.idata;\n }\n isArray = false;\n}\n\nvoid operator/=(const int data) {\n if (type == 1) {\n  idata /= data;\n }\n isArray = false;\n}*/\n\nVariable &Variable::operator[](int index) {\n if (type == 1) {\n  map<int, Variable *> *vec;\n  if ((unsigned int)idata < Engine::vecList->size() && idata >= 0 && isArray) {\n   vec = Engine::vecList->at(idata);\n  } else {\n   vec = new map<int, Variable *>();\n   Engine::vecList->push_back(vec);\n   idata = Engine::vecList->size()-1;\n   isArray = true;\n   cout << \"new vector \" << idata << endl;\n  }\n  if (vec->find(index) != vec->end()) {\n   return *(vec->find(index)->second);\n  } else {\n   Variable *var = new Variable(0);\n   vec->insert(vec->begin(),pair<int,Variable*>(index,var));\n   return *(var);\n  }\n }\n return *(new Variable(-4));\n}\n\nbool operator<(const Variable &var1, int data) {\n if (var1.type == 1) {\n  if (var1.idata < data) {\n   return true;\n  }\n }\n return false;\n}\n\nbool operator<(const Variable &var1, const Variable &var2) {\n if (var1.type == 1 && var2.type == 1) {\n  if (var1.idata < var2.idata) {\n   return true;\n  }\n }\n return false;\n}\n\n/*bool operator>=(const Variable &var1, int data) {\n if (var1.type == 1) {\n  if (var1.idata >= data) {\n   return true;\n  }\n }\n return false;\n}\n\nbool operator>=(const Variable &var1, const Variable &var2) {\n if (var1.type == 1 && var2.type == 1) {\n  if (var1.idata >= var2.idata) {\n   return true;\n  }\n }\n return false;\n}\n\nbool operator<=(const Variable &var1, int data) {\n if (var1.type == 1) {\n  if (var1.idata <= data) {\n   return true;\n  }\n }\n return false;\n}\n\nbool operator<=(const Variable &var1, const Variable &var2) {\n if (var1.type == 1 && var2.type == 1) {\n  if (var1.idata <= var2.idata) {\n   return true;\n  }\n }\n return false;\n}*/\n\nostream& operator<<(ostream &output, const Variable &var) {\n if (var.isArray) {\n  output << \"Array=>\";\n }\n if (var.type == 1) {\n  output << var.idata;\n } else if (var.type == 2) {\n  output << var.sdata;\n } else {\n  output << \"(UNDEF)\";\n }\n return output;\n}\n\nbool operator==(const Variable &var1, string data) {\n if (var1.type == 2) {\n  if (var1.sdata == data) {\n   return true;\n  }\n }\n return false;\n}\n\nbool operator==(const Variable &var1, int data) {\n if (var1.type == 1) {\n  if (var1.idata == data) {\n   return true;\n  }\n }\n return false;\n}\n\nbool operator==(const Variable &var1, const Variable &var2) {\n if (var1.type == 1 && var2.type == 1) {\n  if (var1.idata == var2.idata) {\n   return true;\n  }\n } else if (var1.type == 2 && var2.type == 2) {\n  if (var1.sdata == var2.sdata) {\n   return true;\n  }\n }\n return false;\n}\n\nbool operator!=(const Variable &var1, string data) {\n return !(var1 == data);\n}\n\nbool operator!=(const Variable &var1, int data) {\n return !(var1 == data);\n}\n\nbool operator!=(const Variable &var1, const Variable &var2) {\n return !(var1 == var2);\n}\n\nstring Variable::getS() {\n if (type == 2) {\n  return sdata;\n } else {\n  return \"\";\n }\n}\n\nint Variable::getI() {\n if (type == 1) {\n  return idata;\n } else {\n  return 0;\n }\n}\n\n";
files.insert(pair<string,string*>("Variable_cpp",&Variable_cpp));
Room_h = "#ifndef ROOMH\n#define ROOMH\n\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n#include \"Objects.h\"\n\nclass Room {\npublic:\n Room(int i, string t, int w, int h, int sp = 30);\n        virtual void initInstances();\n virtual void create();\n void draw();\n\n string getTitle() {return title;}\n int getId() {return id;}\n        int getWidth() {return width;}\n        int getheight() {return height;}\n        vector<Object *> getInstances() {return instances;}\n        int getSpeed() {return speed;}\n\n int id;\n string title;\n        int width;\n        int height;\n        vector<Object *> instances;\n        int speed;\n\n float r;\n float g;\n float b;\n};\n\n#endif\n\n";
files.insert(pair<string,string*>("Room_h",&Room_h));
common_cpp = "#include \"common.h\"\n\nvoid draw_character(char letter, float x, float y) {\n if (x == 0) x++;\n if (y == 0) y++;\n \n int i,j;\n bool found = false;\n\n for (i=0;i<(signed int)Engine::currentFont->chars->size();i++) {\n  if (Engine::currentFont->chars->at(i) == letter) {\n   found = true;\n   break;\n  }\n }\n\n if (!found) {\n  return;\n }\n\n Letter *let = Engine::currentFont->letters->find(letter)->second;\n if (let == NULL) {\n  return;\n }\n glColor3f(0,0,0);\n\n glBegin(GL_POINTS);\n for (i=0;i<let->height;i++) {\n  for (j=0;j<let->width;j++) {\n   int index = (i*let->width+j)*3;\n   if (let->pixels[index] != -1 || let->pixels[index+1] != -1 || let->pixels[index+2] != -1) {\n    double r = let->pixels[index];\n    double g = let->pixels[index+1];\n    double b = let->pixels[index+2];\n    glColor3d(r/255,g/255,b/255);\n    glVertex2f(j+x,i+y);\n   }\n  }\n }\n glEnd();\n glColor3d(Engine::r,Engine::g,Engine::b);\n\n}\n\nint instance_create(unsigned int id, int x, int y) {\n        int ret = noone;\n        Object *inst = NULL;\n /* -- OBJECT CREATION -- */\n cout << \"common.cpp instance_create \" << id << endl;\n        if (inst != NULL) {\n                Engine::instanceref.push_back(inst);\n                Engine::instances->find(id)->second->push_back(inst);\n  if (Engine::currentRoom != NULL) {\n   cout << \"common.cpp instance_create room is not null\" << endl;\n   Engine::currentRoom->instances.push_back(inst);\n  }\n                ret = Engine::instanceid;\n                Engine::instanceid++;\n        }\n        return ret;\n}\n\nvoid draw_sprite(unsigned int sprite, int offset, float x, float y) {\n        if (sprite >= Engine::imageref.size()) {\n                return;\n        }\n        Engine::imageref[sprite]->draw(x,y);\n}\n\nvoid draw_line(float x1, float y1, float x2, float y2) {\n if (x1 == 0)x1++;\n if (x2 == 0)x2++;\n if (y1 == 0)y1++;\n if (y2 == 0)y2++;\n glColor3f(Engine::r,Engine::g,Engine::b);\n glBegin(GL_LINES);\n glVertex3f(x1,y1,0);\n glVertex3f(x2,y2,0);\n glEnd();\n}\n\nvoid draw_line_color(float x1, float y1, float x2, float y2, float r, float g, float b) {\n if (x1 == 0)x1++;\n if (x2 == 0)x2++;\n if (y1 == 0)y1++;\n if (y2 == 0)y2++;\n glColor3f(r,g,b);\n glBegin(GL_LINES);\n glVertex3f(x1,y1,0);\n glVertex3f(x2,y2,0);\n glEnd();\n glColor3f(Engine::r,Engine::g,Engine::b);\n}\n\nint instance_number(int object) {\n instancemap::iterator itor = Engine::instances->find(object);\n if (itor == Engine::instances->end()) {\n  return 0;\n }\n return itor->second->size();\n}\n\nint instance_find(int object, int number) {\n instancemap::iterator itor = Engine::instances->find(object);\n if (itor == Engine::instances->end()) {\n  return 0;\n }\n objlist *list = itor->second;\n return list->at(number)->id;\n}\n\nvoid draw_set_color_rgb(int r, int g, int b) {\n Engine::r = ((double)r)/255;\n Engine::g = ((double)g)/255;\n Engine::b = ((double)b)/255;\n}\n\nvoid draw_point(float x, float y) {\n glColor3f(Engine::r,Engine::g,Engine::b);\n glBegin(GL_POINTS);\n glVertex2f(x,y);\n glEnd();\n}\n\nvoid draw_text(string text, float x, float y) {\n unsigned int i;\n for (i=0;i<text.size();i++) {\n  char let = text.at(i);\n  draw_character(let,x,y);\n  x += Engine::currentFont->widthOf(let);\n }\n}\n\nvoid draw_text(Variable *text, float x, float y) {\n draw_text(text->getS(),x,y);\n}\n\nvoid draw_rectangle(float x1, float y1, float x2, float y2) {\n if (x1 == 0)x1++;\n if (x2 == 0)x2++;\n if (y1 == 0)y1++;\n if (y2 == 0)y2++;\n glColor3f(Engine::r,Engine::g,Engine::b);\n glBegin(GL_POLYGON);\n glVertex3f(x1,y1,0);\n glVertex3f(x2,y1,0);\n glVertex3f(x2,y2,0);\n glVertex3f(x1,y2,0);\n glEnd();\n}\n\nvoid draw_rectangle_color(float x1, float y1, float x2, float y2, float r, float g, float b) {\n if (x1 == 0)x1++;\n if (x2 == 0)x2++;\n if (y1 == 0)y1++;\n if (y2 == 0)y2++;\n glColor3f(r,g,b);\n glBegin(GL_POLYGON);\n glVertex3f(x1,y1,0);\n glVertex3f(x2,y1,0);\n glVertex3f(x2,y2,0);\n glVertex3f(x1,y2,0);\n glEnd();\n glColor3f(Engine::r,Engine::g,Engine::b);\n}\n\nvoid Tokenize(const string& str,\n                      vector<string>& tokens,\n                      const string& delimiters = \" \")\n{\n    // Skip delimiters at beginning.\n    string::size_type lastPos = str.find_first_not_of(delimiters, 0);\n    // Find first \"non-delimiter\".\n    string::size_type pos     = str.find_first_of(delimiters, lastPos);\n\n    while (string::npos != pos || string::npos != lastPos)\n    {\n        // Found a token, add it to the vector.\n        tokens.push_back(str.substr(lastPos, pos - lastPos));\n        // Skip delimiters.  Note the \"not_of\"\n        lastPos = str.find_first_not_of(delimiters, pos);\n        // Find next \"non-delimiter\"\n        pos = str.find_first_of(delimiters, lastPos);\n    }\n}\n\n\nint file_text_open_write(string filename) {\n fstream file;\n file.open(filename.c_str(),ios::out);\n if (!file.is_open()) {\n  cout << \"common.cpp file_text_open_write cannot open \" << filename << endl;\n  return -4;\n }\n \n unsigned int i;\n for (i=0;i<Engine::filePtrWrite->size();i++) {\n  if (Engine::filePtrWrite->at(i) == NULL) {\n   Engine::filePtrWrite->at(i) = &file;\n   return i;\n  }\n }\n\n Engine::filePtrWrite->push_back(&file);\n return Engine::filePtrWrite->size()-1;\n}\n\nvoid file_text_close(int handle) {\n if (handle < 0) return;\n if (Engine::filePtrWrite->size() > (unsigned int)handle) {\n  fstream *file = Engine::filePtrWrite->at(handle);\n  if (file != NULL) {\n   file->close();\n   delete(file);\n  }\n  Engine::filePtrWrite->at(handle) = NULL;\n }\n}\n\nvoid file_text_write_string(int handle, string data) {\n \n}\n\nint ds_list_create() { \n vector<Variable *> *vec = new vector<Variable *>();\n Engine::vectors->push_back(vec);\n return Engine::vectors->size()-1;\n}\n\nvoid ds_list_add(Variable &id2, Variable &value) {\n int id = id2.getI();\n if ((signed int)Engine::vectors->size() <= id) {\n  return;\n }\n if (Engine::vectors->at(id) == NULL) {\n  return;\n }\n Variable *var = new Variable(value.getS());\n cout << var << \" \" << value << endl;\n Engine::vectors->at(id)->push_back(var);\n}\n\nvoid ds_list_add(Variable &id2, const char *value) {\n int id = id2.getI();\n if ((signed int)Engine::vectors->size() <= id) {\n  return;\n }\n if (Engine::vectors->at(id) == NULL) {\n  return;\n }\n Variable *var = new Variable(value);\n Engine::vectors->at(id)->push_back(var);\n}\n\nvoid ds_list_add(Variable &id2, int value) {\n int id = id2.getI();\n if ((signed int)Engine::vectors->size() <= id) {\n  return;\n }\n if (Engine::vectors->at(id) == NULL) {\n  return;\n }\n Variable *var = new Variable(value);\n Engine::vectors->at(id)->push_back(var);\n}\n\nVariable &ds_list_find_value(int id, int pos) {\n if ((signed int)Engine::vectors->size() <= id) {\n  return *(new Variable(-4));\n }\n if (Engine::vectors->at(id) == NULL) {\n  return *(new Variable(-4));\n }\n if ((signed int)Engine::vectors->at(id)->size() <= pos) {\n  return *(new Variable(-4));\n }\n return *(Engine::vectors->at(id)->at(pos));\n}\n\nint ds_list_size(int id) {\n if ((signed int)Engine::vectors->size() <= id) {\n  return -4;\n }\n return Engine::vectors->at(id)->size();\n}\n\n\nint round(Variable *data) {\n return (int)data;\n}\n\n";
files.insert(pair<string,string*>("common_cpp",&common_cpp));
}
